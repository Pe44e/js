// This file is auto-generated by @hey-api/openapi-ts

export type InitiateAuthenticationData = {
	/**
	 * Authentication Initiate Request
	 * Request to initiate authentication flow. Choose one of the supported authentication methods: sms, email, oauth, passkey, or siwe. The required fields depend on the authentication method selected.
	 */
	body?:
		| {
				/**
				 * Authentication method: SMS
				 */
				method: "sms";
				/**
				 * Phone number in E.164 format (e.g., +1234567890)
				 */
				phone: string;
		  }
		| {
				/**
				 * Authentication method: Email
				 */
				method: "email";
				/**
				 * Email address for verification code
				 */
				email: string;
		  }
		| {
				/**
				 * Authentication method: OAuth
				 */
				method: "oauth";
				/**
				 * Social login provider
				 */
				provider:
					| "google"
					| "apple"
					| "facebook"
					| "discord"
					| "farcaster"
					| "telegram"
					| "line"
					| "x"
					| "coinbase"
					| "github"
					| "twitch"
					| "steam"
					| "tiktok";
				/**
				 * Custom redirect URL after OAuth completion
				 */
				redirectUrl?: string;
		  }
		| {
				/**
				 * Authentication method: Passkey
				 */
				method: "passkey";
				/**
				 * Whether to create a new passkey or use existing one
				 */
				type: "sign-up" | "sign-in";
				/**
				 * Username for passkey (optional, for identification)
				 */
				username?: string;
		  }
		| {
				/**
				 * Authentication method: Sign-In with Ethereum
				 */
				method: "siwe";
				/**
				 * Ethereum wallet address for SIWE
				 */
				address: string;
				/**
				 * Chain ID for SIWE (defaults to 1)
				 */
				chainId?: number;
		  };
	path?: never;
	query?: never;
	url: "/v1/auth/initiate";
};

export type InitiateAuthenticationErrors = {
	/**
	 * Invalid request - Check your method and parameters
	 */
	400: unknown;
	/**
	 * Rate limit exceeded - Please wait before trying again
	 */
	429: unknown;
};

export type InitiateAuthenticationResponses = {
	/**
	 * Authentication Initiate Response
	 * Response from authentication initiation. Contains method-specific data needed to complete authentication.
	 */
	200:
		| {
				/**
				 * Authentication method: SMS
				 */
				method: "sms";
				/**
				 * Whether the SMS code was sent successfully
				 */
				success: boolean;
		  }
		| {
				/**
				 * Authentication method: Email
				 */
				method: "email";
				/**
				 * Whether the email code was sent successfully
				 */
				success: boolean;
		  }
		| {
				/**
				 * Authentication method: OAuth
				 */
				method: "oauth";
				/**
				 * URL to redirect user for OAuth authentication
				 */
				redirectUrl: string;
		  }
		| {
				/**
				 * Authentication method: Passkey
				 */
				method: "passkey";
				/**
				 * Server verification ID for passkey
				 */
				serverVerificationId: string;
				/**
				 * Base64-encoded WebAuthn challenge
				 */
				challenge: string;
				/**
				 * Challenge type (sign-up or sign-in)
				 */
				type: string;
		  }
		| {
				/**
				 * Authentication method: Sign-In with Ethereum
				 */
				method: "siwe";
				/**
				 * SIWE message string to be signed
				 */
				payload: string;
		  };
};

export type InitiateAuthenticationResponse =
	InitiateAuthenticationResponses[keyof InitiateAuthenticationResponses];

export type CompleteAuthenticationData = {
	/**
	 * Authentication Complete Request
	 * Request to complete authentication flow. Choose the same method used in initiate: sms, email, oauth, passkey, siwe, guest, or custom. The required fields depend on the authentication method.
	 */
	body?:
		| {
				/**
				 * Authentication method: SMS
				 */
				method: "sms";
				/**
				 * Phone number that received the code
				 */
				phone: string;
				/**
				 * Verification code received via SMS
				 */
				code: string;
		  }
		| {
				/**
				 * Authentication method: Email
				 */
				method: "email";
				/**
				 * Email address that received the code
				 */
				email: string;
				/**
				 * Verification code received via email
				 */
				code: string;
		  }
		| {
				/**
				 * Authentication method: Passkey
				 */
				method: "passkey";
				/**
				 * Passkey operation type
				 */
				type: "sign-up" | "sign-in";
				/**
				 * Base64-encoded authenticator data
				 */
				authenticatorData: string;
				/**
				 * Base64-encoded credential ID
				 */
				credentialId: string;
				/**
				 * Server verification ID from initiate response
				 */
				serverVerificationId: string;
				/**
				 * Base64-encoded client data JSON
				 */
				clientData: string;
				/**
				 * Base64-encoded signature (for sign-in)
				 */
				signature?: string;
				/**
				 * Origin of the request
				 */
				origin?: string;
				/**
				 * Relying party identifier
				 */
				rpId?: string;
				/**
				 * Username for the passkey
				 */
				username?: string;
				/**
				 * Credential data for passkey registration
				 */
				credential?: {
					/**
					 * Public key for the credential
					 */
					publicKey: string;
					/**
					 * Algorithm used for the credential
					 */
					algorithm: "RS256" | "ES256";
				};
		  }
		| {
				/**
				 * Authentication method: Sign-In with Ethereum
				 */
				method: "siwe";
				/**
				 * Hex-encoded signed SIWE message
				 */
				signature: string;
				/**
				 * The original SIWE payload that was signed
				 */
				payload: string;
		  }
		| {
				/**
				 * Authentication method: Custom
				 */
				method: "custom";
				/**
				 * Custom authentication type
				 */
				type: "jwt" | "auth-payload";
				/**
				 * JWT token for OIDC authentication
				 */
				jwt?: unknown;
				/**
				 * Custom authentication payload
				 */
				payload?: unknown;
		  }
		| {
				/**
				 * Authentication method: Guest
				 */
				method: "guest";
				/**
				 * Optional guest session ID - if not provided, a random one will be generated with no persistence guarantees.
				 */
				sessionId?: string;
		  };
	path?: never;
	query?: never;
	url: "/v1/auth/complete";
};

export type CompleteAuthenticationErrors = {
	/**
	 * Invalid credentials or request - Check your challenge ID and verification data
	 */
	400: unknown;
	/**
	 * Rate limit exceeded - Please wait before trying again
	 */
	429: unknown;
};

export type CompleteAuthenticationResponses = {
	/**
	 * Successful authentication response. Returns wallet address plus authentication tokens.
	 */
	200: {
		/**
		 * Whether this is a newly created user/wallet
		 */
		isNewUser: boolean;
		/**
		 * JWT authentication token for API access
		 */
		token: string;
		/**
		 * Type of authentication completed
		 */
		type: string;
		/**
		 * The wallet address
		 */
		walletAddress: string;
	};
};

export type CompleteAuthenticationResponse =
	CompleteAuthenticationResponses[keyof CompleteAuthenticationResponses];

export type LinkAuthenticationData = {
	/**
	 * Authentication Link Request
	 * Request body for linking an additional authentication method or external wallet to the currently authenticated user.
	 */
	body?: {
		/**
		 * Authentication token for the account that should be linked to the currently authenticated wallet.
		 */
		accountAuthTokenToConnect: string;
	};
	path?: never;
	query?: never;
	url: "/v1/auth/link";
};

export type LinkAuthenticationErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Wallet authentication required. Include Authorization: Bearer <jwt> header.
	 */
	401: unknown;
	/**
	 * Rate limit exceeded - Please wait before trying again
	 */
	429: unknown;
	/**
	 * Third-party provider did not return any linked accounts after processing the request.
	 */
	502: unknown;
};

export type LinkAuthenticationResponses = {
	/**
	 * Authentication Link Response
	 * Response returned after successfully linking an additional authentication provider. The response includes all linked profiles for the user.
	 */
	200: {
		/**
		 * AuthenticationProviderDetail
		 * Authentication provider details with type-based discrimination
		 */
		linkedAccounts: Array<
			| {
					email: string;
					emailVerified: boolean;
					familyName?: string;
					givenName?: string;
					hd: string;
					id: string;
					locale: string;
					name?: string;
					picture: string;
					type: "google";
			  }
			| {
					email?: string;
					firstName?: string;
					id: string;
					lastName?: string;
					name?: string;
					picture?: string;
					type: "facebook";
			  }
			| {
					email?: string;
					emailVerified: boolean;
					id: string;
					isPrivateEmail: boolean;
					type: "apple";
			  }
			| {
					avatar?: string;
					id: string;
					name?: string;
					type: "github";
					username: string;
			  }
			| {
					avatar: string;
					email?: string;
					emailVerified: boolean;
					id: string;
					type: "discord";
					username: string;
			  }
			| {
					avatar?: string;
					id: string;
					name: string;
					type: "coinbase";
			  }
			| {
					id: string;
					name: string;
					type: "x";
					username: string;
					profileImageUrl?: string;
			  }
			| {
					id: string;
					displayName: string;
					avatarUrl: string;
					unionId?: string;
					type: "tiktok";
			  }
			| {
					avatar?: string;
					id: string;
					metadata: {
						avatar: {
							large?: string;
							medium?: string;
							small?: string;
						};
						personaname?: string;
						profileurl?: string;
						realname?: string;
					};
					type: "steam";
					username?: string;
			  }
			| {
					firstName?: string;
					id: string;
					lastName?: string;
					picture?: string;
					type: "telegram";
					username?: string;
			  }
			| {
					avatar?: string;
					description?: string;
					email?: string;
					id: string;
					type: "twitch";
					username: string;
			  }
			| {
					avatar?: string;
					id: string;
					type: "line";
					username?: string;
			  }
			| {
					fid: string;
					id: string;
					type: "farcaster";
					walletAddress?: string;
			  }
			| {
					algorithm: string;
					credentialId: string;
					publicKey: string;
					type: "passkey";
			  }
			| {
					email: string;
					id: string;
					type: "email";
			  }
			| {
					id: string;
					pregeneratedIdentifier: string;
					type: "pre_generation";
			  }
			| {
					id: string;
					phone: string;
					type: "phone";
			  }
			| {
					id: string;
					type: "siwe";
					walletAddress: string;
			  }
			| {
					id: string;
					type: "guest";
			  }
			| {
					id: string;
					type: "backend";
			  }
			| {
					identifier: string;
					type: "server";
			  }
			| {
					authProviderId?: string;
					email?: string;
					id: string;
					phone?: string;
					type: "custom_jwt";
					walletAddress?: string;
			  }
			| {
					authProviderId?: string;
					email?: string;
					id: string;
					phone?: string;
					type: "custom_auth_endpoint";
					walletAddress?: string;
			  }
		>;
	};
};

export type LinkAuthenticationResponse =
	LinkAuthenticationResponses[keyof LinkAuthenticationResponses];

export type UnlinkAuthenticationData = {
	/**
	 * Authentication Unlink Request
	 * Request body for unlinking an authentication provider or wallet from the currently authenticated user.
	 */
	body?: {
		/**
		 * Authentication provider type to disconnect
		 */
		type:
			| "apple"
			| "coinbase"
			| "discord"
			| "email"
			| "facebook"
			| "farcaster"
			| "github"
			| "google"
			| "guest"
			| "line"
			| "passkey"
			| "phone"
			| "siwe"
			| "steam"
			| "telegram"
			| "twitch"
			| "x"
			| "tiktok"
			| "backend"
			| "wallet"
			| "custom_auth_endpoint"
			| "custom_jwt";
		/**
		 * Identifiers for the provider profile that should be disconnected
		 */
		details: {
			address?: string;
			/**
			 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
			 */
			walletAddress?: string;
			email?: string;
			phone?: string;
			id?: string;
		};
		/**
		 * If true, allows the account to be deleted when unlinking removes the last authentication method. Defaults to false when omitted.
		 */
		allowAccountDeletion?: boolean;
	};
	path?: never;
	query?: never;
	url: "/v1/auth/unlink";
};

export type UnlinkAuthenticationErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Wallet authentication required. Include Authorization: Bearer <jwt> header.
	 */
	401: unknown;
	/**
	 * Rate limit exceeded - Please wait before trying again
	 */
	429: unknown;
	/**
	 * Third-party provider did not return any linked accounts after processing the request.
	 */
	502: unknown;
};

export type UnlinkAuthenticationResponses = {
	/**
	 * Authentication Link Response
	 * Response returned after successfully linking an additional authentication provider. The response includes all linked profiles for the user.
	 */
	200: {
		/**
		 * AuthenticationProviderDetail
		 * Authentication provider details with type-based discrimination
		 */
		linkedAccounts: Array<
			| {
					email: string;
					emailVerified: boolean;
					familyName?: string;
					givenName?: string;
					hd: string;
					id: string;
					locale: string;
					name?: string;
					picture: string;
					type: "google";
			  }
			| {
					email?: string;
					firstName?: string;
					id: string;
					lastName?: string;
					name?: string;
					picture?: string;
					type: "facebook";
			  }
			| {
					email?: string;
					emailVerified: boolean;
					id: string;
					isPrivateEmail: boolean;
					type: "apple";
			  }
			| {
					avatar?: string;
					id: string;
					name?: string;
					type: "github";
					username: string;
			  }
			| {
					avatar: string;
					email?: string;
					emailVerified: boolean;
					id: string;
					type: "discord";
					username: string;
			  }
			| {
					avatar?: string;
					id: string;
					name: string;
					type: "coinbase";
			  }
			| {
					id: string;
					name: string;
					type: "x";
					username: string;
					profileImageUrl?: string;
			  }
			| {
					id: string;
					displayName: string;
					avatarUrl: string;
					unionId?: string;
					type: "tiktok";
			  }
			| {
					avatar?: string;
					id: string;
					metadata: {
						avatar: {
							large?: string;
							medium?: string;
							small?: string;
						};
						personaname?: string;
						profileurl?: string;
						realname?: string;
					};
					type: "steam";
					username?: string;
			  }
			| {
					firstName?: string;
					id: string;
					lastName?: string;
					picture?: string;
					type: "telegram";
					username?: string;
			  }
			| {
					avatar?: string;
					description?: string;
					email?: string;
					id: string;
					type: "twitch";
					username: string;
			  }
			| {
					avatar?: string;
					id: string;
					type: "line";
					username?: string;
			  }
			| {
					fid: string;
					id: string;
					type: "farcaster";
					walletAddress?: string;
			  }
			| {
					algorithm: string;
					credentialId: string;
					publicKey: string;
					type: "passkey";
			  }
			| {
					email: string;
					id: string;
					type: "email";
			  }
			| {
					id: string;
					pregeneratedIdentifier: string;
					type: "pre_generation";
			  }
			| {
					id: string;
					phone: string;
					type: "phone";
			  }
			| {
					id: string;
					type: "siwe";
					walletAddress: string;
			  }
			| {
					id: string;
					type: "guest";
			  }
			| {
					id: string;
					type: "backend";
			  }
			| {
					identifier: string;
					type: "server";
			  }
			| {
					authProviderId?: string;
					email?: string;
					id: string;
					phone?: string;
					type: "custom_jwt";
					walletAddress?: string;
			  }
			| {
					authProviderId?: string;
					email?: string;
					id: string;
					phone?: string;
					type: "custom_auth_endpoint";
					walletAddress?: string;
			  }
		>;
	};
};

export type UnlinkAuthenticationResponse =
	UnlinkAuthenticationResponses[keyof UnlinkAuthenticationResponses];

export type SocialAuthenticationData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The OAuth provider to use
		 */
		provider:
			| "google"
			| "apple"
			| "facebook"
			| "discord"
			| "farcaster"
			| "telegram"
			| "line"
			| "x"
			| "coinbase"
			| "github"
			| "twitch"
			| "steam"
			| "tiktok";
		/**
		 * URL to redirect the user to after OAuth completion
		 */
		redirectUrl: string;
		/**
		 * Client ID (alternative to x-client-id header for standard OAuth flows)
		 */
		clientId?: string;
	};
	url: "/v1/auth/social";
};

export type SocialAuthenticationErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
};

export type GetMyWalletData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v1/wallets/me";
};

export type GetMyWalletErrors = {
	/**
	 * Authentication required. The request must include a valid `Authorization: Bearer <jwt>` header.
	 */
	401: unknown;
	/**
	 * Wallet not found. The authenticated user does not exist in the system.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to service unavailability or unexpected server errors.
	 */
	500: unknown;
};

export type GetMyWalletResponses = {
	/**
	 * Wallet retrieved successfully. Returns comprehensive user information including wallet addresses, public key, and linked wallets.
	 */
	200: {
		result: {
			/**
			 * The EOA (Externally Owned Wallet) address of the wallet. This is the traditional wallet address.
			 */
			address?: string;
			/**
			 * The date and time the wallet was created
			 */
			createdAt?: string;
			/**
			 * AuthenticationProviderDetail
			 * Authentication provider details with type-based discrimination
			 */
			profiles: Array<
				| {
						email: string;
						emailVerified: boolean;
						familyName?: string;
						givenName?: string;
						hd: string;
						id: string;
						locale: string;
						name?: string;
						picture: string;
						type: "google";
				  }
				| {
						email?: string;
						firstName?: string;
						id: string;
						lastName?: string;
						name?: string;
						picture?: string;
						type: "facebook";
				  }
				| {
						email?: string;
						emailVerified: boolean;
						id: string;
						isPrivateEmail: boolean;
						type: "apple";
				  }
				| {
						avatar?: string;
						id: string;
						name?: string;
						type: "github";
						username: string;
				  }
				| {
						avatar: string;
						email?: string;
						emailVerified: boolean;
						id: string;
						type: "discord";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						name: string;
						type: "coinbase";
				  }
				| {
						id: string;
						name: string;
						type: "x";
						username: string;
						profileImageUrl?: string;
				  }
				| {
						id: string;
						displayName: string;
						avatarUrl: string;
						unionId?: string;
						type: "tiktok";
				  }
				| {
						avatar?: string;
						id: string;
						metadata: {
							avatar: {
								large?: string;
								medium?: string;
								small?: string;
							};
							personaname?: string;
							profileurl?: string;
							realname?: string;
						};
						type: "steam";
						username?: string;
				  }
				| {
						firstName?: string;
						id: string;
						lastName?: string;
						picture?: string;
						type: "telegram";
						username?: string;
				  }
				| {
						avatar?: string;
						description?: string;
						email?: string;
						id: string;
						type: "twitch";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						type: "line";
						username?: string;
				  }
				| {
						fid: string;
						id: string;
						type: "farcaster";
						walletAddress?: string;
				  }
				| {
						algorithm: string;
						credentialId: string;
						publicKey: string;
						type: "passkey";
				  }
				| {
						email: string;
						id: string;
						type: "email";
				  }
				| {
						id: string;
						pregeneratedIdentifier: string;
						type: "pre_generation";
				  }
				| {
						id: string;
						phone: string;
						type: "phone";
				  }
				| {
						id: string;
						type: "siwe";
						walletAddress: string;
				  }
				| {
						id: string;
						type: "guest";
				  }
				| {
						id: string;
						type: "backend";
				  }
				| {
						identifier: string;
						type: "server";
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_jwt";
						walletAddress?: string;
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_auth_endpoint";
						walletAddress?: string;
				  }
			>;
			/**
			 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced wallet features.
			 */
			smartWalletAddress?: string;
			/**
			 * The wallet's public key in hexadecimal format. Useful for peer-to-peer encryption and cryptographic operations.
			 */
			publicKey?: string;
		};
	};
};

export type GetMyWalletResponse =
	GetMyWalletResponses[keyof GetMyWalletResponses];

export type ListUserWalletsData = {
	body?: never;
	path?: never;
	query?: {
		limit?: number;
		page?: number;
		email?: string;
		phone?: string;
		address?: string;
		externalWalletAddress?: string;
		id?: string;
	};
	url: "/v1/wallets/user";
};

export type ListUserWalletsErrors = {
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to service unavailability or unexpected server errors.
	 */
	500: unknown;
};

export type ListUserWalletsResponses = {
	/**
	 * Returns a list of user wallet addresses, smart wallet addresses, and auth details.
	 */
	200: {
		result: {
			/**
			 * Pagination information
			 */
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			/**
			 * Array of user wallets
			 */
			wallets: Array<{
				/**
				 * The EOA (Externally Owned Wallet) address of the wallet. This is the traditional wallet address.
				 */
				address?: string;
				/**
				 * The date and time the wallet was created
				 */
				createdAt?: string;
				/**
				 * AuthenticationProviderDetail
				 * Authentication provider details with type-based discrimination
				 */
				profiles: Array<
					| {
							email: string;
							emailVerified: boolean;
							familyName?: string;
							givenName?: string;
							hd: string;
							id: string;
							locale: string;
							name?: string;
							picture: string;
							type: "google";
					  }
					| {
							email?: string;
							firstName?: string;
							id: string;
							lastName?: string;
							name?: string;
							picture?: string;
							type: "facebook";
					  }
					| {
							email?: string;
							emailVerified: boolean;
							id: string;
							isPrivateEmail: boolean;
							type: "apple";
					  }
					| {
							avatar?: string;
							id: string;
							name?: string;
							type: "github";
							username: string;
					  }
					| {
							avatar: string;
							email?: string;
							emailVerified: boolean;
							id: string;
							type: "discord";
							username: string;
					  }
					| {
							avatar?: string;
							id: string;
							name: string;
							type: "coinbase";
					  }
					| {
							id: string;
							name: string;
							type: "x";
							username: string;
							profileImageUrl?: string;
					  }
					| {
							id: string;
							displayName: string;
							avatarUrl: string;
							unionId?: string;
							type: "tiktok";
					  }
					| {
							avatar?: string;
							id: string;
							metadata: {
								avatar: {
									large?: string;
									medium?: string;
									small?: string;
								};
								personaname?: string;
								profileurl?: string;
								realname?: string;
							};
							type: "steam";
							username?: string;
					  }
					| {
							firstName?: string;
							id: string;
							lastName?: string;
							picture?: string;
							type: "telegram";
							username?: string;
					  }
					| {
							avatar?: string;
							description?: string;
							email?: string;
							id: string;
							type: "twitch";
							username: string;
					  }
					| {
							avatar?: string;
							id: string;
							type: "line";
							username?: string;
					  }
					| {
							fid: string;
							id: string;
							type: "farcaster";
							walletAddress?: string;
					  }
					| {
							algorithm: string;
							credentialId: string;
							publicKey: string;
							type: "passkey";
					  }
					| {
							email: string;
							id: string;
							type: "email";
					  }
					| {
							id: string;
							pregeneratedIdentifier: string;
							type: "pre_generation";
					  }
					| {
							id: string;
							phone: string;
							type: "phone";
					  }
					| {
							id: string;
							type: "siwe";
							walletAddress: string;
					  }
					| {
							id: string;
							type: "guest";
					  }
					| {
							id: string;
							type: "backend";
					  }
					| {
							identifier: string;
							type: "server";
					  }
					| {
							authProviderId?: string;
							email?: string;
							id: string;
							phone?: string;
							type: "custom_jwt";
							walletAddress?: string;
					  }
					| {
							authProviderId?: string;
							email?: string;
							id: string;
							phone?: string;
							type: "custom_auth_endpoint";
							walletAddress?: string;
					  }
				>;
				/**
				 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced wallet features.
				 */
				smartWalletAddress?: string;
				/**
				 * The wallet's public key in hexadecimal format. Useful for peer-to-peer encryption and cryptographic operations.
				 */
				publicKey?: string;
			}>;
		};
	};
};

export type ListUserWalletsResponse =
	ListUserWalletsResponses[keyof ListUserWalletsResponses];

export type CreateUserWalletData = {
	/**
	 * Request body for pre-generating a wallet
	 */
	body?: {
		type:
			| "google"
			| "apple"
			| "facebook"
			| "discord"
			| "email"
			| "phone"
			| "custom_auth_endpoint"
			| "custom_jwt"
			| "siwe";
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		walletAddress?: string;
		email?: string;
		phone?: string;
		userId?: string;
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/user";
};

export type CreateUserWalletErrors = {
	/**
	 * Invalid request. This may occur due to missing required fields based on the authentication strategy, invalid strategy, or malformed request data.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to service unavailability or unexpected server errors.
	 */
	500: unknown;
};

export type CreateUserWalletResponses = {
	/**
	 * Successfully created a user wallet with wallet.
	 */
	200: {
		result: {
			/**
			 * The EOA (Externally Owned Wallet) address of the wallet. This is the traditional wallet address.
			 */
			address?: string;
			/**
			 * The date and time the wallet was created
			 */
			createdAt?: string;
			/**
			 * AuthenticationProviderDetail
			 * Authentication provider details with type-based discrimination
			 */
			profiles: Array<
				| {
						email: string;
						emailVerified: boolean;
						familyName?: string;
						givenName?: string;
						hd: string;
						id: string;
						locale: string;
						name?: string;
						picture: string;
						type: "google";
				  }
				| {
						email?: string;
						firstName?: string;
						id: string;
						lastName?: string;
						name?: string;
						picture?: string;
						type: "facebook";
				  }
				| {
						email?: string;
						emailVerified: boolean;
						id: string;
						isPrivateEmail: boolean;
						type: "apple";
				  }
				| {
						avatar?: string;
						id: string;
						name?: string;
						type: "github";
						username: string;
				  }
				| {
						avatar: string;
						email?: string;
						emailVerified: boolean;
						id: string;
						type: "discord";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						name: string;
						type: "coinbase";
				  }
				| {
						id: string;
						name: string;
						type: "x";
						username: string;
						profileImageUrl?: string;
				  }
				| {
						id: string;
						displayName: string;
						avatarUrl: string;
						unionId?: string;
						type: "tiktok";
				  }
				| {
						avatar?: string;
						id: string;
						metadata: {
							avatar: {
								large?: string;
								medium?: string;
								small?: string;
							};
							personaname?: string;
							profileurl?: string;
							realname?: string;
						};
						type: "steam";
						username?: string;
				  }
				| {
						firstName?: string;
						id: string;
						lastName?: string;
						picture?: string;
						type: "telegram";
						username?: string;
				  }
				| {
						avatar?: string;
						description?: string;
						email?: string;
						id: string;
						type: "twitch";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						type: "line";
						username?: string;
				  }
				| {
						fid: string;
						id: string;
						type: "farcaster";
						walletAddress?: string;
				  }
				| {
						algorithm: string;
						credentialId: string;
						publicKey: string;
						type: "passkey";
				  }
				| {
						email: string;
						id: string;
						type: "email";
				  }
				| {
						id: string;
						pregeneratedIdentifier: string;
						type: "pre_generation";
				  }
				| {
						id: string;
						phone: string;
						type: "phone";
				  }
				| {
						id: string;
						type: "siwe";
						walletAddress: string;
				  }
				| {
						id: string;
						type: "guest";
				  }
				| {
						id: string;
						type: "backend";
				  }
				| {
						identifier: string;
						type: "server";
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_jwt";
						walletAddress?: string;
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_auth_endpoint";
						walletAddress?: string;
				  }
			>;
			/**
			 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced wallet features.
			 */
			smartWalletAddress?: string;
			/**
			 * The wallet's public key in hexadecimal format. Useful for peer-to-peer encryption and cryptographic operations.
			 */
			publicKey?: string;
		};
	};
};

export type CreateUserWalletResponse =
	CreateUserWalletResponses[keyof CreateUserWalletResponses];

export type ListServerWalletsData = {
	body?: never;
	path?: never;
	query?: {
		limit?: number;
		page?: number;
	};
	url: "/v1/wallets/server";
};

export type ListServerWalletsErrors = {
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to service unavailability or unexpected server errors.
	 */
	500: unknown;
};

export type ListServerWalletsResponses = {
	/**
	 * Returns a list of server wallet addresses, smart wallet addresses, and auth details.
	 */
	200: {
		result: {
			/**
			 * Pagination information
			 */
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			/**
			 * Array of server wallets
			 */
			wallets: Array<{
				/**
				 * The EOA (Externally Owned Wallet) address of the wallet. This is the traditional wallet address.
				 */
				address?: string;
				/**
				 * The date and time the wallet was created
				 */
				createdAt?: string;
				/**
				 * AuthenticationProviderDetail
				 * Authentication provider details with type-based discrimination
				 */
				profiles: Array<
					| {
							email: string;
							emailVerified: boolean;
							familyName?: string;
							givenName?: string;
							hd: string;
							id: string;
							locale: string;
							name?: string;
							picture: string;
							type: "google";
					  }
					| {
							email?: string;
							firstName?: string;
							id: string;
							lastName?: string;
							name?: string;
							picture?: string;
							type: "facebook";
					  }
					| {
							email?: string;
							emailVerified: boolean;
							id: string;
							isPrivateEmail: boolean;
							type: "apple";
					  }
					| {
							avatar?: string;
							id: string;
							name?: string;
							type: "github";
							username: string;
					  }
					| {
							avatar: string;
							email?: string;
							emailVerified: boolean;
							id: string;
							type: "discord";
							username: string;
					  }
					| {
							avatar?: string;
							id: string;
							name: string;
							type: "coinbase";
					  }
					| {
							id: string;
							name: string;
							type: "x";
							username: string;
							profileImageUrl?: string;
					  }
					| {
							id: string;
							displayName: string;
							avatarUrl: string;
							unionId?: string;
							type: "tiktok";
					  }
					| {
							avatar?: string;
							id: string;
							metadata: {
								avatar: {
									large?: string;
									medium?: string;
									small?: string;
								};
								personaname?: string;
								profileurl?: string;
								realname?: string;
							};
							type: "steam";
							username?: string;
					  }
					| {
							firstName?: string;
							id: string;
							lastName?: string;
							picture?: string;
							type: "telegram";
							username?: string;
					  }
					| {
							avatar?: string;
							description?: string;
							email?: string;
							id: string;
							type: "twitch";
							username: string;
					  }
					| {
							avatar?: string;
							id: string;
							type: "line";
							username?: string;
					  }
					| {
							fid: string;
							id: string;
							type: "farcaster";
							walletAddress?: string;
					  }
					| {
							algorithm: string;
							credentialId: string;
							publicKey: string;
							type: "passkey";
					  }
					| {
							email: string;
							id: string;
							type: "email";
					  }
					| {
							id: string;
							pregeneratedIdentifier: string;
							type: "pre_generation";
					  }
					| {
							id: string;
							phone: string;
							type: "phone";
					  }
					| {
							id: string;
							type: "siwe";
							walletAddress: string;
					  }
					| {
							id: string;
							type: "guest";
					  }
					| {
							id: string;
							type: "backend";
					  }
					| {
							identifier: string;
							type: "server";
					  }
					| {
							authProviderId?: string;
							email?: string;
							id: string;
							phone?: string;
							type: "custom_jwt";
							walletAddress?: string;
					  }
					| {
							authProviderId?: string;
							email?: string;
							id: string;
							phone?: string;
							type: "custom_auth_endpoint";
							walletAddress?: string;
					  }
				>;
				/**
				 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced wallet features.
				 */
				smartWalletAddress?: string;
				/**
				 * The wallet's public key in hexadecimal format. Useful for peer-to-peer encryption and cryptographic operations.
				 */
				publicKey?: string;
			}>;
		};
	};
};

export type ListServerWalletsResponse =
	ListServerWalletsResponses[keyof ListServerWalletsResponses];

export type CreateServerWalletData = {
	/**
	 * Request body for creating a wallet
	 */
	body?: {
		/**
		 * Unique identifier for wallet creation or retrieval. Can be user ID, email, or any unique string. The same identifier will always return the same wallet.
		 */
		identifier: string;
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/server";
};

export type CreateServerWalletErrors = {
	/**
	 * Invalid request parameters. This occurs when the identifier format is invalid or required parameters are missing.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to wallet service unavailability, smart wallet deployment issues, or unexpected server errors.
	 */
	500: unknown;
};

export type CreateServerWalletResponses = {
	/**
	 * Server wallet created or connected successfully. Returns wallet addresses for subsequent operations.
	 */
	200: {
		result: {
			/**
			 * The EOA (Externally Owned Wallet) address of the wallet. This is the traditional wallet address.
			 */
			address?: string;
			/**
			 * The date and time the wallet was created
			 */
			createdAt?: string;
			/**
			 * AuthenticationProviderDetail
			 * Authentication provider details with type-based discrimination
			 */
			profiles: Array<
				| {
						email: string;
						emailVerified: boolean;
						familyName?: string;
						givenName?: string;
						hd: string;
						id: string;
						locale: string;
						name?: string;
						picture: string;
						type: "google";
				  }
				| {
						email?: string;
						firstName?: string;
						id: string;
						lastName?: string;
						name?: string;
						picture?: string;
						type: "facebook";
				  }
				| {
						email?: string;
						emailVerified: boolean;
						id: string;
						isPrivateEmail: boolean;
						type: "apple";
				  }
				| {
						avatar?: string;
						id: string;
						name?: string;
						type: "github";
						username: string;
				  }
				| {
						avatar: string;
						email?: string;
						emailVerified: boolean;
						id: string;
						type: "discord";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						name: string;
						type: "coinbase";
				  }
				| {
						id: string;
						name: string;
						type: "x";
						username: string;
						profileImageUrl?: string;
				  }
				| {
						id: string;
						displayName: string;
						avatarUrl: string;
						unionId?: string;
						type: "tiktok";
				  }
				| {
						avatar?: string;
						id: string;
						metadata: {
							avatar: {
								large?: string;
								medium?: string;
								small?: string;
							};
							personaname?: string;
							profileurl?: string;
							realname?: string;
						};
						type: "steam";
						username?: string;
				  }
				| {
						firstName?: string;
						id: string;
						lastName?: string;
						picture?: string;
						type: "telegram";
						username?: string;
				  }
				| {
						avatar?: string;
						description?: string;
						email?: string;
						id: string;
						type: "twitch";
						username: string;
				  }
				| {
						avatar?: string;
						id: string;
						type: "line";
						username?: string;
				  }
				| {
						fid: string;
						id: string;
						type: "farcaster";
						walletAddress?: string;
				  }
				| {
						algorithm: string;
						credentialId: string;
						publicKey: string;
						type: "passkey";
				  }
				| {
						email: string;
						id: string;
						type: "email";
				  }
				| {
						id: string;
						pregeneratedIdentifier: string;
						type: "pre_generation";
				  }
				| {
						id: string;
						phone: string;
						type: "phone";
				  }
				| {
						id: string;
						type: "siwe";
						walletAddress: string;
				  }
				| {
						id: string;
						type: "guest";
				  }
				| {
						id: string;
						type: "backend";
				  }
				| {
						identifier: string;
						type: "server";
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_jwt";
						walletAddress?: string;
				  }
				| {
						authProviderId?: string;
						email?: string;
						id: string;
						phone?: string;
						type: "custom_auth_endpoint";
						walletAddress?: string;
				  }
			>;
			/**
			 * The smart wallet address with EIP-4337 support. This address enables gasless transactions and advanced wallet features.
			 */
			smartWalletAddress?: string;
			/**
			 * The wallet's public key in hexadecimal format. Useful for peer-to-peer encryption and cryptographic operations.
			 */
			publicKey?: string;
		};
	};
};

export type CreateServerWalletResponse =
	CreateServerWalletResponses[keyof CreateServerWalletResponses];

export type GetWalletBalanceData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request balance data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
		/**
		 * The token contract address. Omit for native token (ETH, MATIC, etc.).
		 */
		tokenAddress?: string;
	};
	url: "/v1/wallets/{address}/balance";
};

export type GetWalletBalanceErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or chain IDs are invalid.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or `x-secret-key` for backend usage.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to blockchain connectivity issues, RPC service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletBalanceResponses = {
	/**
	 * Wallet native balances retrieved successfully. Returns detailed native token balance information for each chain including token metadata and formatted values.
	 */
	200: {
		result: Array<{
			/**
			 * The blockchain network ID
			 */
			chainId: number;
			/**
			 * Number of decimal places for the token
			 */
			decimals: number;
			/**
			 * Human-readable balance formatted with appropriate decimal places
			 */
			displayValue: string;
			/**
			 * The token name (e.g., 'Ether', 'USD Coin')
			 */
			name: string;
			/**
			 * The token symbol (e.g., 'ETH', 'USDC')
			 */
			symbol: string;
			/**
			 * The token contract address. Returns zero address (0x0...0) for native tokens.
			 */
			tokenAddress: string;
			/**
			 * Raw balance value as string in smallest unit (wei for ETH, etc.)
			 */
			value: string;
		}>;
	};
};

export type GetWalletBalanceResponse =
	GetWalletBalanceResponses[keyof GetWalletBalanceResponses];

export type GetWalletTransactionsData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		address: string;
	};
	query: {
		/**
		 * Filter by block timestamp (Unix timestamp) greater than or equal to this value
		 */
		filterBlockTimestampGte?: number;
		/**
		 * Filter by block timestamp (Unix timestamp) less than or equal to this value
		 */
		filterBlockTimestampLte?: number;
		/**
		 * Filter by block number greater than or equal to this value
		 */
		filterBlockNumberGte?: number;
		/**
		 * Filter by block number less than or equal to this value
		 */
		filterBlockNumberLte?: number;
		/**
		 * Filter by transaction value (in wei) greater than this value
		 */
		filterValueGt?: string;
		/**
		 * Filter by function selector (4-byte method ID), e.g., '0xa9059cbb' for ERC-20 transfer
		 */
		filterFunctionSelector?: string;
		/**
		 * Current page number
		 */
		page?: number;
		/**
		 * Number of items per page
		 */
		limit?: number;
		/**
		 * Sort order: 'asc' for ascending, 'desc' for descending
		 */
		sortOrder?: "asc" | "desc";
		/**
		 * Chain ID(s) to request transaction data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
	};
	url: "/v1/wallets/{address}/transactions";
};

export type GetWalletTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or `x-secret-key` for backend usage.
	 */
	401: unknown;
	/**
	 * Wallet not found or no transactions available for the specified wallet address on the given blockchain networks.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletTransactionsResponses = {
	/**
	 * Wallet transactions retrieved successfully. Returns transaction data with metadata including pagination information and chain details. Includes decoded function calls when ABI is available.
	 */
	200: {
		result: {
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			/**
			 * Array of wallet transactions.
			 */
			transactions: Array<{
				/**
				 * The hash of the block containing this transaction.
				 */
				blockHash: string;
				/**
				 * The block number containing this transaction.
				 */
				blockNumber: number;
				/**
				 * The timestamp of the block (Unix timestamp).
				 */
				blockTimestamp: number;
				/**
				 * The chain ID where the transaction occurred.
				 */
				chainId: string;
				/**
				 * Contract address created if this was a contract creation transaction.
				 */
				contractAddress?: string;
				/**
				 * Total gas used by all transactions in this block up to and including this one.
				 */
				cumulativeGasUsed?: number;
				/**
				 * The transaction input data.
				 */
				data: string;
				/**
				 * Decoded transaction data (included when ABI is available).
				 */
				decoded?: {
					/**
					 * Object containing decoded function parameters.
					 */
					inputs: {
						[key: string]: unknown;
					};
					/**
					 * The function name.
					 */
					name: string;
					/**
					 * The function signature.
					 */
					signature: string;
				};
				/**
				 * The effective gas price paid (in wei as string).
				 */
				effectiveGasPrice?: string;
				/**
				 * The address that initiated the transaction.
				 */
				fromAddress: string;
				/**
				 * The function selector (first 4 bytes of the transaction data).
				 */
				functionSelector: string;
				/**
				 * The gas limit for the transaction.
				 */
				gas: number;
				/**
				 * The gas price used for the transaction (in wei as string).
				 */
				gasPrice: string;
				/**
				 * The amount of gas used by the transaction.
				 */
				gasUsed?: number;
				/**
				 * The transaction hash.
				 */
				hash: string;
				/**
				 * Maximum fee per gas (EIP-1559).
				 */
				maxFeePerGas?: string;
				/**
				 * Maximum priority fee per gas (EIP-1559).
				 */
				maxPriorityFeePerGas?: string;
				/**
				 * The transaction nonce.
				 */
				nonce: number;
				/**
				 * The transaction status (1 for success, 0 for failure).
				 */
				status: number;
				/**
				 * The address that received the transaction.
				 */
				toAddress: string;
				/**
				 * The index of the transaction within the block.
				 */
				transactionIndex: number;
				/**
				 * The transaction type (0=legacy, 1=EIP-2930, 2=EIP-1559).
				 */
				transactionType?: number;
				/**
				 * The value transferred in the transaction (in wei as string).
				 */
				value: string;
			}>;
		};
	};
};

export type GetWalletTransactionsResponse =
	GetWalletTransactionsResponses[keyof GetWalletTransactionsResponses];

export type GetWalletTokensData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request token data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
		/**
		 * Token addresses to filter by. If provided, only tokens with these addresses will be returned.
		 */
		tokenAddresses?: Array<string>;
		/**
		 * The number of tokens to return per chain (default: 20, max: 500).
		 */
		limit?: number;
		/**
		 * The page number for pagination (default: 1, max: 20).
		 */
		page?: number;
		/**
		 * Whether to include token metadata (default: true).
		 */
		metadata?: "true" | "false";
		/**
		 * Whether to resolve metadata links to fetch additional token information (default: true).
		 */
		resolveMetadataLinks?: "true" | "false";
		/**
		 * Whether to include tokens marked as spam (default: false).
		 */
		includeSpam?: "true" | "false";
		/**
		 * Whether to include native tokens (e.g., ETH, MATIC) in the results (default: true).
		 */
		includeNative?: "true" | "false";
		/**
		 * Field to sort tokens by: 'balance' for token balance, 'token_address' for token address, 'token_price' for token price, 'usd_value' for USD value (default: usd_value).
		 */
		sortBy?: "balance" | "token_address" | "token_price" | "usd_value";
		/**
		 * Sort order: 'asc' for ascending, 'desc' for descending (default: desc).
		 */
		sortOrder?: "asc" | "desc";
		/**
		 * Whether to include tokens without price data (default: true).
		 */
		includeWithoutPrice?: "true" | "false";
	};
	url: "/v1/wallets/{address}/tokens";
};

export type GetWalletTokensErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or `x-secret-key` for backend usage.
	 */
	401: unknown;
	/**
	 * Wallet not found or no tokens available for the specified wallet address on the given blockchain networks.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletTokensResponses = {
	/**
	 * Wallet tokens retrieved successfully. Returns token data with metadata including pagination information and chain details. Includes token balances, metadata, and price information when available. Results are sorted by the specified criteria (default: USD value descending) and filtered according to the provided parameters.
	 */
	200: {
		result: {
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			/**
			 * Array of wallet tokens.
			 */
			tokens: Array<{
				/**
				 * The token balance as a string
				 */
				balance: string;
				/**
				 * The chain ID of the token
				 */
				chain_id: number;
				/**
				 * The number of decimal places
				 */
				decimals?: number;
				/**
				 * The token name
				 */
				name?: string;
				/**
				 * The token icon URI
				 */
				icon_uri?: string;
				/**
				 * Price data
				 */
				prices?: {
					[key: string]: number;
				};
				/**
				 * Price data for the token
				 */
				price_data?: {
					/**
					 * The circulating supply of the token
					 */
					circulating_supply?: number;
					/**
					 * The market cap of the token in USD
					 */
					market_cap_usd?: number;
					/**
					 * The percentage change of the token in the last 24 hours
					 */
					percent_change_24h?: number;
					/**
					 * The timestamp of the latest price update
					 */
					price_timestamp?: string;
					/**
					 * The price of the token in USD
					 */
					price_usd?: number;
					/**
					 * The total supply of the token
					 */
					total_supply?: number;
					/**
					 * The value of the token balance in USD
					 */
					usd_value?: number;
					/**
					 * The volume of the token in USD
					 */
					volume_24h_usd?: number;
				};
				/**
				 * The token symbol
				 */
				symbol?: string;
				/**
				 * The contract address of the token
				 */
				token_address: string;
			}>;
		};
	};
};

export type GetWalletTokensResponse =
	GetWalletTokensResponses[keyof GetWalletTokensResponses];

export type GetWalletNftsData = {
	body?: never;
	path: {
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		address: string;
	};
	query: {
		/**
		 * Chain ID(s) to request NFT data for. You can specify multiple chain IDs by repeating the parameter, up to a maximum of 50. Example: ?chainId=1&chainId=137
		 */
		chainId: Array<number>;
		/**
		 * NFT contract addresses to filter by. If provided, only NFTs with these addresses will be returned.
		 */
		contractAddresses?: Array<string>;
		/**
		 * The number of NFTs to return per chain (default: 20, max: 500).
		 */
		limit?: number;
		/**
		 * The page number for pagination (default: 1, max: 20).
		 */
		page?: number;
	};
	url: "/v1/wallets/{address}/nfts";
};

export type GetWalletNftsErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId array is empty or exceeds the maximum limit of 50, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or `x-secret-key` for backend usage.
	 */
	401: unknown;
	/**
	 * Wallet not found or no NFTs available for the specified wallet address on the given blockchain networks.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetWalletNftsResponses = {
	/**
	 * Wallet NFTs retrieved successfully. Returns NFT data with metadata including pagination information and chain details. Includes NFT metadata, attributes, and collection information when available.
	 */
	200: {
		result: {
			/**
			 * Array of wallet NFTs.
			 */
			nfts: Array<{
				/**
				 * The animation URL of the NFT
				 */
				animation_url?: string;
				/**
				 * The attributes/traits of the NFT
				 */
				attributes?: Array<{
					/**
					 * The display type
					 */
					display_type?: string;
					/**
					 * The trait type
					 */
					trait_type?: string;
					/**
					 * The trait value
					 */
					value?: string | number;
				}>;
				/**
				 * The chain ID of the NFT
				 */
				chain_id: number;
				/**
				 * Collection information
				 */
				collection?: {
					/**
					 * The collection description
					 */
					description?: string;
					/**
					 * The collection external URL
					 */
					external_url?: string;
					/**
					 * The collection image URL
					 */
					image?: string;
					/**
					 * The collection name
					 */
					name?: string;
				};
				/**
				 * The description of the NFT
				 */
				description?: string;
				/**
				 * The external URL of the NFT
				 */
				external_url?: string;
				/**
				 * The image URL of the NFT
				 */
				image_url?: string;
				/**
				 * Additional metadata for the NFT
				 */
				metadata?: {
					[key: string]: unknown;
				};
				/**
				 * The name of the NFT
				 */
				name?: string;
				/**
				 * The contract address of the NFT collection
				 */
				token_address: string;
				/**
				 * The token ID of the NFT
				 */
				token_id: string;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetWalletNftsResponse =
	GetWalletNftsResponses[keyof GetWalletNftsResponses];

export type SignMessageData = {
	/**
	 * Request body for signing a message
	 */
	body?: {
		/**
		 * The wallet address or ENS name that will sign the message.
		 */
		from: string;
		/**
		 * The blockchain network identifier where the signing will occur. Common values include: 1 (Ethereum), 137 (Polygon), 56 (BSC).
		 */
		chainId: number;
		/**
		 * The message to be signed. Can be plain text or hexadecimal format (starting with 0x). The format is automatically detected.
		 */
		message: string;
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/sign-message";
};

export type SignMessageErrors = {
	/**
	 * Invalid request parameters. This occurs when the wallet address format is invalid, chainId is not supported, or the message format is incorrect.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to wallet connectivity issues, signing service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type SignMessageResponses = {
	/**
	 * Message signed successfully. Returns the cryptographic signature that can be used for verification.
	 */
	200: {
		result: {
			/**
			 * The cryptographic signature in hexadecimal format. This can be used for verification and authentication purposes.
			 */
			signature: string;
		};
	};
};

export type SignMessageResponse =
	SignMessageResponses[keyof SignMessageResponses];

export type SignTypedDataData = {
	/**
	 * Request body for signing typed data
	 */
	body?: {
		/**
		 * The wallet address or ENS name that will sign the typed data.
		 */
		from: string;
		/**
		 * The blockchain network identifier for EIP-712 domain separation.
		 */
		chainId: number;
		/**
		 * EIP-712 domain separator containing contract and chain information for signature verification.
		 */
		domain: {
			/**
			 * Chain ID as string for domain separation
			 */
			chainId?: string;
			/**
			 * The domain name (e.g., token name)
			 */
			name?: string;
			/**
			 * Optional salt for additional entropy
			 */
			salt?: string;
			/**
			 * The contract address that will verify this signature
			 */
			verifyingContract?: string;
			/**
			 * Domain version for signature compatibility
			 */
			version?: string;
		};
		/**
		 * The structured data to be signed, matching the defined types schema.
		 */
		message: {
			[key: string]: unknown;
		};
		/**
		 * The primary type name from the types object that defines the main structure being signed.
		 */
		primaryType: string;
		/**
		 * Type definitions for the structured data, following EIP-712 specifications.
		 */
		types: {
			[key: string]: Array<{
				/**
				 * The field name
				 */
				name: string;
				/**
				 * The Solidity type (e.g., 'address', 'uint256')
				 */
				type: string;
			}>;
		};
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/sign-typed-data";
};

export type SignTypedDataErrors = {
	/**
	 * Invalid request parameters. This occurs when the typed data structure is malformed, domain parameters are incorrect, or wallet address format is invalid.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include valid `x-wallet-access-token` headers for accessing the wallet, as well as a x-client-id (frontend) or x-secret-key (backend) for project authentication.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to wallet connectivity issues, signing service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type SignTypedDataResponses = {
	/**
	 * Typed data signed successfully. Returns the EIP-712 compliant signature that can be used for on-chain verification.
	 */
	200: {
		result: {
			/**
			 * The cryptographic signature in hexadecimal format. This can be used for verification and authentication purposes.
			 */
			signature: string;
		};
	};
};

export type SignTypedDataResponse =
	SignTypedDataResponses[keyof SignTypedDataResponses];

export type SendTokensData = {
	/**
	 * Request body for sending tokens to multiple recipients. Supports native tokens, ERC20, ERC721, and ERC1155 transfers based on the provided parameters.
	 */
	body?: {
		/**
		 * The wallet address or ENS name that will send the tokens. If omitted, the project wallet will be used if available.
		 */
		from?: string;
		/**
		 * The blockchain network identifier where the transfer will be executed.
		 */
		chainId: number;
		/**
		 * Array of recipients and quantities. Maximum 100 recipients per request.
		 */
		recipients: Array<{
			/**
			 * The recipient wallet address or ENS name
			 */
			address: string;
			/**
			 * The amount to send. For native tokens and ERC20: amount in wei/smallest unit. For ERC721: should be '1'. For ERC1155: the number of tokens to transfer.
			 */
			quantity: string;
		}>;
		/**
		 * The token contract address. Omit for native token (ETH, MATIC, etc.) transfers.
		 */
		tokenAddress?: string;
		/**
		 * The token ID for NFT transfers (ERC721/ERC1155). Required for NFT transfers.
		 */
		tokenId?: string;
	};
	path?: never;
	query?: never;
	url: "/v1/wallets/send";
};

export type SendTokensErrors = {
	/**
	 * Invalid request parameters. This occurs when token parameters are malformed, insufficient balance, invalid contract data, or unsupported token type.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to blockchain connectivity issues, gas estimation failures, contract execution errors, or unexpected server errors.
	 */
	500: unknown;
};

export type SendTokensResponses = {
	/**
	 * Tokens sent successfully. Returns transaction IDs for tracking and monitoring.
	 */
	200: {
		result: {
			/**
			 * Array of transaction IDs for the submitted transfers. One ID per recipient.
			 */
			transactionIds: Array<string>;
		};
	};
};

export type SendTokensResponse = SendTokensResponses[keyof SendTokensResponses];

export type ListContractsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * The number of contracts to return (default: 20, max: 100).
		 */
		limit?: number;
		/**
		 * The page number for pagination (default: 1).
		 */
		page?: number;
	};
	url: "/v1/contracts";
};

export type ListContractsErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Rate limit exceeded
	 */
	429: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type ListContractsResponses = {
	/**
	 * Successfully retrieved list of contracts
	 */
	200: {
		result: {
			/**
			 * Array of contracts imported by the client.
			 */
			contracts: Array<{
				/**
				 * The contract address.
				 */
				address: string;
				/**
				 * The chain ID where the contract is deployed.
				 */
				chainId: string;
				/**
				 * The date when the contract was deployed.
				 */
				deployedAt?: string;
				/**
				 * The contract ID.
				 */
				id?: string;
				/**
				 * The date when the contract was imported to the dashboard.
				 */
				importedAt: string;
				/**
				 * The contract name, if available.
				 */
				name?: string;
				/**
				 * The contract symbol, if available.
				 */
				symbol?: string;
				/**
				 * The contract type (e.g., ERC20, ERC721, etc.).
				 */
				type?: string;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type ListContractsResponse =
	ListContractsResponses[keyof ListContractsResponses];

export type DeployContractData = {
	/**
	 * Contract deployment specification for raw bytecode deployment.
	 */
	body?: {
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
		/**
		 * The wallet address or ENS name that will deploy the contract. If omitted, the project wallet will be used if available.
		 */
		from?: string;
		/**
		 * The contract bytecode as a hex string.
		 */
		bytecode: string;
		/**
		 * The contract ABI array.
		 */
		abi: Array<unknown>;
		/**
		 * Object containing constructor parameters for the contract deployment (e.g., { param1: 'value1', param2: 123 }).
		 */
		constructorParams?: {
			[key: string]: unknown;
		};
		/**
		 * Optional salt value for deterministic contract deployment.
		 */
		salt?: string;
	};
	path?: never;
	query?: never;
	url: "/v1/contracts";
};

export type DeployContractErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Rate limit exceeded
	 */
	429: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type DeployContractResponses = {
	/**
	 * Contract deployed successfully
	 */
	200: {
		result: {
			/**
			 * The deployed contract address.
			 */
			address: string;
			/**
			 * The chain ID where the contract was deployed.
			 */
			chainId: number;
			/**
			 * The unique identifier for the transaction that deployed the contract. Will not be returned if the contract was already deployed at the predicted address.
			 */
			transactionId?: string;
		};
	};
};

export type DeployContractResponse =
	DeployContractResponses[keyof DeployContractResponses];

export type ReadContractData = {
	body?: {
		/**
		 * Array of contract method calls to execute. Each call specifies a contract address, method signature, and optional parameters.
		 */
		calls: Array<{
			/**
			 * The smart contract address or ENS name.
			 */
			contractAddress: string;
			/**
			 * The contract function signature to call (e.g., 'function approve(address spender, uint256 amount)' or `function balanceOf(address)`). Must start with 'function' followed by the function name and parameters as defined in the contract ABI.
			 */
			method: string;
			/**
			 * Array of parameters to pass to the contract method, in the correct order and format.
			 */
			params?: Array<unknown>;
			/**
			 * Amount of native token to send with the transaction in wei. Required for payable methods.
			 */
			value?: string;
		}>;
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
	};
	path?: never;
	query?: never;
	url: "/v1/contracts/read";
};

export type ReadContractErrors = {
	/**
	 * Invalid request parameters. This occurs when the chainId is not supported, contract addresses are invalid, function signatures are malformed, or the calls array is empty.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or `x-secret-key` for backend usage.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to engine connectivity issues, RPC node unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type ReadContractResponses = {
	/**
	 * Contract read operations completed successfully. Returns an array of results corresponding to each input call, including both successful and failed operations.
	 */
	200: {
		/**
		 * Array of results corresponding to each contract read call. Results are returned in the same order as the input calls.
		 */
		result: Array<{
			/**
			 * The result of the contract read operation. The type and format depend on the method's return value as defined in the contract ABI.
			 */
			data?: unknown;
			/**
			 * Error message if the contract read operation failed.
			 */
			error?: string;
			/**
			 * Indicates whether the contract read operation was successful.
			 */
			success: boolean;
		}>;
	};
};

export type ReadContractResponse =
	ReadContractResponses[keyof ReadContractResponses];

export type WriteContractData = {
	body?: {
		/**
		 * Array of contract method calls to execute. Each call specifies a contract address, method signature, and optional parameters.
		 */
		calls: Array<{
			/**
			 * The smart contract address or ENS name.
			 */
			contractAddress: string;
			/**
			 * The contract function signature to call (e.g., 'function approve(address spender, uint256 amount)' or `function balanceOf(address)`). Must start with 'function' followed by the function name and parameters as defined in the contract ABI.
			 */
			method: string;
			/**
			 * Array of parameters to pass to the contract method, in the correct order and format.
			 */
			params?: Array<unknown>;
			/**
			 * Amount of native token to send with the transaction in wei. Required for payable methods.
			 */
			value?: string;
		}>;
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
		/**
		 * The wallet address or ENS name that will send the transaction. If omitted, the project wallet will be used if available.
		 */
		from?: string;
	};
	path?: never;
	query?: never;
	url: "/v1/contracts/write";
};

export type WriteContractErrors = {
	/**
	 * Invalid request parameters. This occurs when contract parameters are malformed, method signatures are invalid, insufficient balance, or unsupported contract methods.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment Required Response
	 * Payment required response when user has insufficient funds. Contains a quote for completing the purchase.
	 */
	402: {
		result: {
			/**
			 * Message to display to the user
			 */
			message: string;
			/**
			 * Link to purchase the product
			 */
			link: string;
			/**
			 * Payment ID
			 */
			id: string;
			/**
			 * Bridge quote for completing the payment
			 */
			quote: {
				/**
				 * Block number when quote was generated
				 */
				blockNumber?: string;
				/**
				 * Destination amount in wei
				 */
				destinationAmount: string;
				/**
				 * Estimated execution time in milliseconds
				 */
				estimatedExecutionTimeMs?: number;
				/**
				 * Quote intent details
				 */
				intent: {
					/**
					 * The amount in wei
					 */
					amount: string;
					/**
					 * Destination chain ID
					 */
					destinationChainId: number;
					/**
					 * Destination token address
					 */
					destinationTokenAddress: string;
					/**
					 * Origin chain ID
					 */
					originChainId: number;
					/**
					 * Origin token address
					 */
					originTokenAddress: string;
					/**
					 * Receiver address
					 */
					receiver: string;
					/**
					 * Sender address
					 */
					sender: string;
				};
				/**
				 * Origin amount in wei
				 */
				originAmount: string;
				/**
				 * Array of steps to complete the bridge operation
				 */
				steps: Array<{
					/**
					 * Origin token information
					 */
					originToken: {
						/**
						 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
						 */
						chainId: number;
						/**
						 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
						 */
						address: string;
						decimals: number;
						symbol: string;
						iconUri?: string;
						/**
						 * Token price in different FIAT currencies.
						 */
						prices: {
							[key: string]: number;
						};
					};
					/**
					 * Destination token information
					 */
					destinationToken: {
						/**
						 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
						 */
						chainId: number;
						/**
						 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
						 */
						address: string;
						decimals: number;
						symbol: string;
						iconUri?: string;
						/**
						 * Token price in different FIAT currencies.
						 */
						prices: {
							[key: string]: number;
						};
					};
					/**
					 * Array of transactions for this step
					 */
					transactions: Array<{
						/**
						 * Blockchain network identifier
						 */
						chainId: number;
						/**
						 * Transaction recipient address
						 */
						to: string;
						/**
						 * Transaction data payload
						 */
						data: string;
						/**
						 * Type of action this transaction performs
						 */
						action: "approval" | "transfer" | "buy" | "sell" | "fee";
						/**
						 * Transaction sender address
						 */
						from?: string;
						/**
						 * Spender address for approval transactions
						 */
						spender?: string;
						/**
						 * Transaction value in wei
						 */
						value?: string;
					}>;
					/**
					 * Origin amount in wei
					 */
					originAmount: string;
					/**
					 * Destination amount in wei
					 */
					destinationAmount: string;
					/**
					 * Estimated execution time in milliseconds
					 */
					estimatedExecutionTimeMs?: number;
				}>;
				/**
				 * Quote timestamp
				 */
				timestamp: number;
			};
		};
	};
	/**
	 * Contract not found. The specified contract address does not exist on the given blockchain network or is not accessible.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to blockchain connectivity issues, gas estimation failures, contract execution errors, or unexpected server errors.
	 */
	500: unknown;
};

export type WriteContractError = WriteContractErrors[keyof WriteContractErrors];

export type WriteContractResponses = {
	/**
	 * Contract write operations submitted successfully. Returns transaction IDs for tracking and monitoring.
	 */
	200: {
		result: {
			/**
			 * Array of unique identifiers for the submitted transactions. Use these to track transaction status.
			 */
			transactionIds: Array<string>;
		};
	};
};

export type WriteContractResponse =
	WriteContractResponses[keyof WriteContractResponses];

export type GetContractTransactionsData = {
	body?: never;
	path: {
		/**
		 * The blockchain network identifier where the contract is deployed.
		 */
		chainId: number;
		/**
		 * The smart contract address or ENS name.
		 */
		address: string;
	};
	query?: {
		/**
		 * Filter by transaction sender address
		 */
		filterFromAddress?: string;
		/**
		 * Filter by transaction recipient address
		 */
		filterToAddress?: string;
		/**
		 * Filter by block timestamp (Unix timestamp) greater than or equal to this value
		 */
		filterBlockTimestampGte?: number;
		/**
		 * Filter by block timestamp (Unix timestamp) less than or equal to this value
		 */
		filterBlockTimestampLte?: number;
		/**
		 * Filter by block number greater than or equal to this value
		 */
		filterBlockNumberGte?: number;
		/**
		 * Filter by block number less than or equal to this value
		 */
		filterBlockNumberLte?: number;
		/**
		 * Filter by transaction value (in wei) greater than this value
		 */
		filterValueGt?: string;
		/**
		 * Filter by function selector (4-byte method ID), e.g., '0xa9059cbb' for ERC-20 transfer
		 */
		filterFunctionSelector?: string;
		/**
		 * Current page number
		 */
		page?: number;
		/**
		 * Number of items per page
		 */
		limit?: number;
		/**
		 * Sort order: 'asc' for ascending, 'desc' for descending
		 */
		sortOrder?: "asc" | "desc";
	};
	url: "/v1/contracts/{chainId}/{address}/transactions";
};

export type GetContractTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when the contract address or chainId format is invalid, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or `x-secret-key` for backend usage.
	 */
	401: unknown;
	/**
	 * Contract not found or no transactions available for the specified contract address on the given blockchain network.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetContractTransactionsResponses = {
	/**
	 * Contract transactions retrieved successfully. Returns transaction data with metadata including pagination information. Includes decoded function calls when ABI is available.
	 */
	200: {
		result: {
			/**
			 * Array of contract transactions.
			 */
			data: Array<{
				/**
				 * The hash of the block containing this transaction.
				 */
				blockHash: string;
				/**
				 * The block number containing this transaction.
				 */
				blockNumber: number;
				/**
				 * The timestamp of the block (Unix timestamp).
				 */
				blockTimestamp: number;
				/**
				 * The chain ID where the transaction occurred.
				 */
				chainId: string;
				/**
				 * Contract address created if this was a contract creation transaction.
				 */
				contractAddress?: string;
				/**
				 * Total gas used by all transactions in this block up to and including this one.
				 */
				cumulativeGasUsed?: number;
				/**
				 * The transaction input data.
				 */
				data: string;
				/**
				 * Decoded transaction data (included when ABI is available).
				 */
				decoded?: {
					/**
					 * Object containing decoded function parameters.
					 */
					inputs: {
						[key: string]: unknown;
					};
					/**
					 * The function name.
					 */
					name: string;
					/**
					 * The function signature.
					 */
					signature: string;
				};
				/**
				 * The effective gas price paid (in wei as string).
				 */
				effectiveGasPrice?: string;
				/**
				 * The address that initiated the transaction.
				 */
				fromAddress: string;
				/**
				 * The function selector (first 4 bytes of the transaction data).
				 */
				functionSelector: string;
				/**
				 * The gas limit for the transaction.
				 */
				gas: number;
				/**
				 * The gas price used for the transaction (in wei as string).
				 */
				gasPrice: string;
				/**
				 * The amount of gas used by the transaction.
				 */
				gasUsed?: number;
				/**
				 * The transaction hash.
				 */
				hash: string;
				/**
				 * Maximum fee per gas (EIP-1559).
				 */
				maxFeePerGas?: string;
				/**
				 * Maximum priority fee per gas (EIP-1559).
				 */
				maxPriorityFeePerGas?: string;
				/**
				 * The transaction nonce.
				 */
				nonce: number;
				/**
				 * The transaction status (1 for success, 0 for failure).
				 */
				status: number;
				/**
				 * The address that received the transaction.
				 */
				toAddress: string;
				/**
				 * The index of the transaction within the block.
				 */
				transactionIndex: number;
				/**
				 * The transaction type (0=legacy, 1=EIP-2930, 2=EIP-1559).
				 */
				transactionType?: number;
				/**
				 * The value transferred in the transaction (in wei as string).
				 */
				value: string;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetContractTransactionsResponse =
	GetContractTransactionsResponses[keyof GetContractTransactionsResponses];

export type GetContractEventsData = {
	body?: never;
	path: {
		/**
		 * The blockchain network identifier where the contract is deployed.
		 */
		chainId: number;
		/**
		 * The smart contract address or ENS name.
		 */
		address: string;
	};
	query?: {
		/**
		 * Filter by event signature hash, e.g., '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' for Transfer event
		 */
		signature?: string;
		/**
		 * Filter by event topic 0 (event signature hash)
		 */
		filterTopic0?: string;
		/**
		 * Filter by event topic 1
		 */
		filterTopic1?: string;
		/**
		 * Filter by event topic 2
		 */
		filterTopic2?: string;
		/**
		 * Filter by event topic 3
		 */
		filterTopic3?: string;
		/**
		 * Filter by block timestamp (Unix timestamp) greater than or equal to this value
		 */
		filterBlockTimestampGte?: number;
		/**
		 * Filter by block timestamp (Unix timestamp) less than or equal to this value
		 */
		filterBlockTimestampLte?: number;
		/**
		 * Filter by block number greater than or equal to this value
		 */
		filterBlockNumberGte?: number;
		/**
		 * Filter by block number less than or equal to this value
		 */
		filterBlockNumberLte?: number;
		/**
		 * Current page number
		 */
		page?: number;
		/**
		 * Number of items per page
		 */
		limit?: number;
		/**
		 * Sort order: 'asc' for ascending, 'desc' for descending
		 */
		sortOrder?: "asc" | "desc";
	};
	url: "/v1/contracts/{chainId}/{address}/events";
};

export type GetContractEventsErrors = {
	/**
	 * Invalid request parameters. This occurs when the contract address or chainId format is invalid, or pagination parameters are out of range.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or `x-secret-key` for backend usage.
	 */
	401: unknown;
	/**
	 * Contract not found or no events available for the specified contract address on the given blockchain network.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, external service unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetContractEventsResponses = {
	/**
	 * Contract events retrieved successfully. Returns event data with metadata including pagination information. Includes decoded event parameters when ABI is available.
	 */
	200: {
		result: {
			/**
			 * Array of contract events.
			 */
			events: Array<{
				/**
				 * The contract address that emitted the event.
				 */
				address: string;
				/**
				 * The hash of the block containing this event.
				 */
				blockHash: string;
				/**
				 * The block number where the event was emitted.
				 */
				blockNumber: number;
				/**
				 * The timestamp of the block (Unix timestamp).
				 */
				blockTimestamp: number;
				/**
				 * The chain ID where the event occurred.
				 */
				chainId: string;
				/**
				 * The non-indexed event data as a hex string.
				 */
				data: string;
				/**
				 * Decoded event data (included when ABI is available).
				 */
				decoded?: {
					/**
					 * The event name.
					 */
					name: string;
					/**
					 * Object containing decoded parameters.
					 */
					params: {
						[key: string]: unknown;
					};
					/**
					 * The event signature.
					 */
					signature: string;
				};
				/**
				 * The index of the log within the transaction.
				 */
				logIndex: number;
				/**
				 * Array of indexed event topics (including event signature).
				 */
				topics: Array<string>;
				/**
				 * The hash of the transaction containing this event.
				 */
				transactionHash: string;
				/**
				 * The index of the transaction within the block.
				 */
				transactionIndex: number;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetContractEventsResponse =
	GetContractEventsResponses[keyof GetContractEventsResponses];

export type GetContractMetadataData = {
	body?: never;
	path: {
		/**
		 * The blockchain network identifier where the contract is deployed.
		 */
		chainId: number;
		/**
		 * The smart contract address or ENS name.
		 */
		address: string;
	};
	query?: never;
	url: "/v1/contracts/{chainId}/{address}/metadata";
};

export type GetContractMetadataErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Contract metadata not found
	 */
	404: unknown;
	/**
	 * Rate limit exceeded
	 */
	429: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type GetContractMetadataResponses = {
	/**
	 * Contract metadata from the thirdweb contract metadata service.
	 */
	200: {
		result: {
			/**
			 * Compiler information including version.
			 */
			compiler?: {
				/**
				 * Solidity compiler version used to compile the contract.
				 */
				version: string;
			};
			/**
			 * Programming language of the contract (e.g., 'Solidity').
			 */
			language?: string;
			/**
			 * Compilation output including ABI and documentation.
			 */
			output?: {
				/**
				 * Contract ABI (Application Binary Interface) as an array of function/event/error definitions.
				 */
				abi?: Array<unknown>;
				/**
				 * Developer documentation extracted from contract comments.
				 */
				devdoc?: {
					[key: string]: unknown;
				};
				/**
				 * User documentation extracted from contract comments.
				 */
				userdoc?: {
					[key: string]: unknown;
				};
			};
			/**
			 * Compilation settings including optimization and target configuration.
			 */
			settings?: {
				/**
				 * Compilation target mapping source file names to contract names.
				 */
				compilationTarget?: {
					[key: string]: string;
				};
				/**
				 * EVM version target for compilation.
				 */
				evmVersion?: string;
				/**
				 * Library addresses for linking.
				 */
				libraries?: {
					[key: string]: unknown;
				};
				/**
				 * Metadata settings for compilation.
				 */
				metadata?: {
					/**
					 * Hash method used for bytecode metadata.
					 */
					bytecodeHash?: string;
				};
				/**
				 * Optimizer settings used during compilation.
				 */
				optimizer?: {
					/**
					 * Whether optimizer is enabled.
					 */
					enabled?: boolean;
					/**
					 * Number of optimizer runs.
					 */
					runs?: number;
				};
				/**
				 * Import remappings used during compilation.
				 */
				remappings?: Array<string>;
			};
			/**
			 * Metadata format version.
			 */
			version?: number;
		};
	};
};

export type GetContractMetadataResponse =
	GetContractMetadataResponses[keyof GetContractMetadataResponses];

export type GetContractSignaturesData = {
	body?: never;
	path: {
		/**
		 * The blockchain network identifier where the contract is deployed.
		 */
		chainId: number;
		/**
		 * The smart contract address or ENS name.
		 */
		address: string;
	};
	query?: never;
	url: "/v1/contracts/{chainId}/{address}/signatures";
};

export type GetContractSignaturesErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-secret-key` header for backend authentication.
	 */
	401: unknown;
	/**
	 * Contract metadata not found or ABI is not available
	 */
	404: unknown;
	/**
	 * Rate limit exceeded
	 */
	429: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type GetContractSignaturesResponses = {
	/**
	 * Contract ABI signatures in human-readable format. These signatures can be used directly with contract interaction methods.
	 */
	200: {
		/**
		 * Array of human-readable ABI signatures including functions and events. Each signature is formatted as a string that can be used directly in contract read/write operations or event filtering.
		 */
		result: Array<string>;
	};
};

export type GetContractSignaturesResponse =
	GetContractSignaturesResponses[keyof GetContractSignaturesResponses];

export type GetTransactionByIdData = {
	body?: never;
	path: {
		/**
		 * Unique identifier of the transaction to retrieve.
		 */
		transactionId: string;
	};
	query?: never;
	url: "/v1/transactions/{transactionId}";
};

export type GetTransactionByIdErrors = {
	/**
	 * Invalid request parameters. This occurs when the transaction ID format is invalid or malformed.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or `x-secret-key` for backend usage.
	 */
	401: unknown;
	/**
	 * Transaction not found. The specified transaction ID does not exist or is not associated with the authenticated client.
	 */
	404: unknown;
	/**
	 * Internal server error. This may occur due to engine connectivity issues, database unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type GetTransactionByIdResponses = {
	/**
	 * Transaction details retrieved successfully. Returns comprehensive transaction information including status, blockchain details, and execution metadata.
	 */
	200: {
		result: {
			/**
			 * Index within transaction batch
			 */
			batchIndex: number;
			/**
			 * ISO timestamp when transaction was cancelled, if applicable
			 */
			cancelledAt: string;
			/**
			 * Blockchain network identifier as string
			 */
			chainId: string;
			/**
			 * Client identifier that initiated the transaction
			 */
			clientId: string;
			/**
			 * ISO timestamp when transaction was confirmed on-chain
			 */
			confirmedAt: string;
			/**
			 * Block number where transaction was confirmed
			 */
			confirmedAtBlockNumber: string;
			/**
			 * ISO timestamp when transaction was created
			 */
			createdAt: string;
			/**
			 * Additional metadata and enriched transaction information
			 */
			enrichedData?: unknown;
			/**
			 * Error message if transaction failed
			 */
			errorMessage: string;
			/**
			 * Parameters used for transaction execution
			 */
			executionParams?: unknown;
			/**
			 * Result data from transaction execution
			 */
			executionResult?: unknown;
			/**
			 * Sender wallet address
			 */
			from: string;
			/**
			 * Unique transaction identifier
			 */
			id: string;
			/**
			 * On-chain transaction hash once confirmed
			 */
			transactionHash: string;
			/**
			 * Original transaction parameters and data
			 */
			transactionParams?: unknown;
			/**
			 * Transaction status
			 */
			status: "QUEUED" | "SUBMITTED" | "CONFIRMED" | "FAILED";
		};
	};
};

export type GetTransactionByIdResponse =
	GetTransactionByIdResponses[keyof GetTransactionByIdResponses];

export type ListTransactionsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Filter transactions by sender wallet address or ENS name.
		 */
		from?: string;
		/**
		 * Number of transactions to return per page (1-100).
		 */
		limit?: number;
		/**
		 * Page number for pagination, starting from 1.
		 */
		page?: number;
	};
	url: "/v1/transactions";
};

export type ListTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when pagination parameters are out of range or wallet address format is invalid.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or `x-secret-key` for backend usage.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to engine connectivity issues, database unavailability, or unexpected server errors.
	 */
	500: unknown;
};

export type ListTransactionsResponses = {
	/**
	 * Transactions retrieved successfully. Returns a paginated list of transactions with metadata including creation and confirmation timestamps.
	 */
	200: {
		result: {
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
			transactions: Array<{
				/**
				 * Index within transaction batch
				 */
				batchIndex: number;
				/**
				 * ISO timestamp when transaction was cancelled, if applicable
				 */
				cancelledAt: string;
				/**
				 * Blockchain network identifier as string
				 */
				chainId: string;
				/**
				 * Client identifier that initiated the transaction
				 */
				clientId: string;
				/**
				 * ISO timestamp when transaction was confirmed on-chain
				 */
				confirmedAt: string;
				/**
				 * Block number where transaction was confirmed
				 */
				confirmedAtBlockNumber: string;
				/**
				 * ISO timestamp when transaction was created
				 */
				createdAt: string;
				/**
				 * Additional metadata and enriched transaction information
				 */
				enrichedData?: unknown;
				/**
				 * Error message if transaction failed
				 */
				errorMessage: string;
				/**
				 * Parameters used for transaction execution
				 */
				executionParams?: unknown;
				/**
				 * Result data from transaction execution
				 */
				executionResult?: unknown;
				/**
				 * Sender wallet address
				 */
				from: string;
				/**
				 * Unique transaction identifier
				 */
				id: string;
				/**
				 * On-chain transaction hash once confirmed
				 */
				transactionHash: string;
				/**
				 * Original transaction parameters and data
				 */
				transactionParams?: unknown;
				/**
				 * Transaction status
				 */
				status: "QUEUED" | "SUBMITTED" | "CONFIRMED" | "FAILED";
			}>;
		};
	};
};

export type ListTransactionsResponse =
	ListTransactionsResponses[keyof ListTransactionsResponses];

export type SendTransactionsData = {
	/**
	 * Transaction Request
	 * Request object containing an array of encoded blockchain transactions to execute. All transactions must use the same from address and chainId. For contract calls, use /v1/contracts/write. For native token transfers, use /v1/wallets/send.
	 */
	body?: {
		/**
		 * The blockchain network identifier where all transactions will be executed.
		 */
		chainId: number;
		/**
		 * The wallet address or ENS name that will send the transaction. If omitted, the project wallet will be used if available.
		 */
		from?: string;
		/**
		 * Array of encoded blockchain transactions to execute. All transactions will use the same from address and chainId.
		 */
		transactions: Array<{
			/**
			 * Transaction data in hexadecimal format for contract interactions or custom payloads.
			 */
			data: string;
			/**
			 * The target address or ENS name for the transaction.
			 */
			to: string;
			/**
			 * Amount of native token to send in wei (smallest unit). Use '0' or omit for non-value transactions.
			 */
			value?: string;
		}>;
	};
	path?: never;
	query?: never;
	url: "/v1/transactions";
};

export type SendTransactionsErrors = {
	/**
	 * Invalid request parameters. This occurs when transaction data is malformed, insufficient balance, or invalid encoded data.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment Required Response
	 * Payment required response when user has insufficient funds. Contains a quote for completing the purchase.
	 */
	402: {
		result: {
			/**
			 * Message to display to the user
			 */
			message: string;
			/**
			 * Link to purchase the product
			 */
			link: string;
			/**
			 * Payment ID
			 */
			id: string;
			/**
			 * Bridge quote for completing the payment
			 */
			quote: {
				/**
				 * Block number when quote was generated
				 */
				blockNumber?: string;
				/**
				 * Destination amount in wei
				 */
				destinationAmount: string;
				/**
				 * Estimated execution time in milliseconds
				 */
				estimatedExecutionTimeMs?: number;
				/**
				 * Quote intent details
				 */
				intent: {
					/**
					 * The amount in wei
					 */
					amount: string;
					/**
					 * Destination chain ID
					 */
					destinationChainId: number;
					/**
					 * Destination token address
					 */
					destinationTokenAddress: string;
					/**
					 * Origin chain ID
					 */
					originChainId: number;
					/**
					 * Origin token address
					 */
					originTokenAddress: string;
					/**
					 * Receiver address
					 */
					receiver: string;
					/**
					 * Sender address
					 */
					sender: string;
				};
				/**
				 * Origin amount in wei
				 */
				originAmount: string;
				/**
				 * Array of steps to complete the bridge operation
				 */
				steps: Array<{
					/**
					 * Origin token information
					 */
					originToken: {
						/**
						 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
						 */
						chainId: number;
						/**
						 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
						 */
						address: string;
						decimals: number;
						symbol: string;
						iconUri?: string;
						/**
						 * Token price in different FIAT currencies.
						 */
						prices: {
							[key: string]: number;
						};
					};
					/**
					 * Destination token information
					 */
					destinationToken: {
						/**
						 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
						 */
						chainId: number;
						/**
						 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
						 */
						address: string;
						decimals: number;
						symbol: string;
						iconUri?: string;
						/**
						 * Token price in different FIAT currencies.
						 */
						prices: {
							[key: string]: number;
						};
					};
					/**
					 * Array of transactions for this step
					 */
					transactions: Array<{
						/**
						 * Blockchain network identifier
						 */
						chainId: number;
						/**
						 * Transaction recipient address
						 */
						to: string;
						/**
						 * Transaction data payload
						 */
						data: string;
						/**
						 * Type of action this transaction performs
						 */
						action: "approval" | "transfer" | "buy" | "sell" | "fee";
						/**
						 * Transaction sender address
						 */
						from?: string;
						/**
						 * Spender address for approval transactions
						 */
						spender?: string;
						/**
						 * Transaction value in wei
						 */
						value?: string;
					}>;
					/**
					 * Origin amount in wei
					 */
					originAmount: string;
					/**
					 * Destination amount in wei
					 */
					destinationAmount: string;
					/**
					 * Estimated execution time in milliseconds
					 */
					estimatedExecutionTimeMs?: number;
				}>;
				/**
				 * Quote timestamp
				 */
				timestamp: number;
			};
		};
	};
	/**
	 * Internal server error. This may occur due to blockchain connectivity issues, gas estimation failures, or unexpected server errors.
	 */
	500: unknown;
};

export type SendTransactionsError =
	SendTransactionsErrors[keyof SendTransactionsErrors];

export type SendTransactionsResponses = {
	/**
	 * Encoded transactions submitted successfully. Returns the transaction IDs for tracking and monitoring.
	 */
	200: {
		result: {
			/**
			 * Array of unique identifiers for the submitted transactions. Use these to track transaction status.
			 */
			transactionIds: Array<string>;
		};
	};
};

export type SendTransactionsResponse =
	SendTransactionsResponses[keyof SendTransactionsResponses];

export type CreatePaymentData = {
	/**
	 * Create Product Request
	 * Request to create a product to be purchased. Users can purchase the product via hosted UI (link is returned), a transaction execution referencing the product ID, or embedded widgets with the product ID.
	 */
	body?: {
		/**
		 * The name of the product
		 */
		name: string;
		/**
		 * The description of the product
		 */
		description: string;
		/**
		 * The URL of the product image
		 */
		imageUrl?: string;
		/**
		 * The token to purchase
		 */
		token: {
			/**
			 * The token address to purchase (use 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native token)
			 */
			address: string;
			/**
			 * The blockchain network where the token is located
			 */
			chainId: number;
			/**
			 * The amount of the token to purchase in wei.
			 */
			amount: string;
		};
		/**
		 * The wallet address or ENS name that will receive the payment for the product
		 */
		recipient: string;
		/**
		 * App specific purchase data for this payment
		 */
		purchaseData?: unknown;
	};
	path?: never;
	query?: never;
	url: "/v1/payments";
};

export type CreatePaymentErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type CreatePaymentResponses = {
	/**
	 * Create Payment Response
	 * Successful payment creation response containing the payment ID and link to purchase the product
	 */
	200: {
		result: {
			/**
			 * The payment ID
			 */
			id: string;
			/**
			 * The link to purchase the product
			 */
			link: string;
		};
	};
};

export type CreatePaymentResponse =
	CreatePaymentResponses[keyof CreatePaymentResponses];

export type GetPaymentHistoryData = {
	body?: never;
	path: {
		id: string;
	};
	query?: never;
	url: "/v1/payments/{id}";
};

export type GetPaymentHistoryErrors = {
	/**
	 * Bad request
	 */
	400: {
		error: string;
	};
	/**
	 * Payment link not found
	 */
	404: {
		error: string;
	};
};

export type GetPaymentHistoryError =
	GetPaymentHistoryErrors[keyof GetPaymentHistoryErrors];

export type GetPaymentHistoryResponses = {
	/**
	 * Payment history retrieved successfully
	 */
	200: {
		/**
		 * List of payments for the client
		 */
		data: Array<{
			id: string;
			blockNumber?: string;
			transactionId?: string;
			onrampId?: string;
			clientId: string;
			/**
			 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
			 */
			sender?: string;
			/**
			 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
			 */
			receiver: string;
			/**
			 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
			 */
			developerFeeRecipient?: string;
			developerFeeBps?: number;
			transactions: Array<{
				chainId: number;
				transactionHash: string;
			}>;
			status: "PENDING" | "COMPLETED" | "FAILED" | "NOT_FOUND";
			type: "buy" | "sell" | "transfer" | "onramp";
			originAmount?: string;
			destinationAmount: string;
			paymentLinkId?: string;
			purchaseData?: unknown;
			originToken?: {
				chainId: number;
				/**
				 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
				 */
				address: string;
				symbol: string;
				name: string;
				decimals: number;
				iconUri?: string;
			};
			destinationToken: {
				chainId: number;
				/**
				 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
				 */
				address: string;
				symbol: string;
				name: string;
				decimals: number;
				iconUri?: string;
			};
			createdAt: string;
		}>;
		meta: {
			/**
			 * Total number of payments
			 */
			totalCount: number;
		};
	};
};

export type GetPaymentHistoryResponse =
	GetPaymentHistoryResponses[keyof GetPaymentHistoryResponses];

export type PaymentsPurchaseData = {
	/**
	 * Purchase Product Request
	 * Request to purchase a product. The system will automatically use your wallet balance to purchase the specified product.
	 */
	body?: {
		/**
		 * The wallet address or ENS name that will purchase the product. If omitted, the project wallet will be used if available.
		 */
		from?: string;
	};
	path: {
		id: string;
	};
	query?: never;
	url: "/v1/payments/{id}";
};

export type PaymentsPurchaseErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment Required Response
	 * Payment required response when user has insufficient funds. Contains a quote for completing the purchase.
	 */
	402: {
		result: {
			/**
			 * Message to display to the user
			 */
			message: string;
			/**
			 * Link to purchase the product
			 */
			link: string;
			/**
			 * Payment ID
			 */
			id: string;
			/**
			 * Bridge quote for completing the payment
			 */
			quote: {
				/**
				 * Block number when quote was generated
				 */
				blockNumber?: string;
				/**
				 * Destination amount in wei
				 */
				destinationAmount: string;
				/**
				 * Estimated execution time in milliseconds
				 */
				estimatedExecutionTimeMs?: number;
				/**
				 * Quote intent details
				 */
				intent: {
					/**
					 * The amount in wei
					 */
					amount: string;
					/**
					 * Destination chain ID
					 */
					destinationChainId: number;
					/**
					 * Destination token address
					 */
					destinationTokenAddress: string;
					/**
					 * Origin chain ID
					 */
					originChainId: number;
					/**
					 * Origin token address
					 */
					originTokenAddress: string;
					/**
					 * Receiver address
					 */
					receiver: string;
					/**
					 * Sender address
					 */
					sender: string;
				};
				/**
				 * Origin amount in wei
				 */
				originAmount: string;
				/**
				 * Array of steps to complete the bridge operation
				 */
				steps: Array<{
					/**
					 * Origin token information
					 */
					originToken: {
						/**
						 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
						 */
						chainId: number;
						/**
						 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
						 */
						address: string;
						decimals: number;
						symbol: string;
						iconUri?: string;
						/**
						 * Token price in different FIAT currencies.
						 */
						prices: {
							[key: string]: number;
						};
					};
					/**
					 * Destination token information
					 */
					destinationToken: {
						/**
						 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
						 */
						chainId: number;
						/**
						 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
						 */
						address: string;
						decimals: number;
						symbol: string;
						iconUri?: string;
						/**
						 * Token price in different FIAT currencies.
						 */
						prices: {
							[key: string]: number;
						};
					};
					/**
					 * Array of transactions for this step
					 */
					transactions: Array<{
						/**
						 * Blockchain network identifier
						 */
						chainId: number;
						/**
						 * Transaction recipient address
						 */
						to: string;
						/**
						 * Transaction data payload
						 */
						data: string;
						/**
						 * Type of action this transaction performs
						 */
						action: "approval" | "transfer" | "buy" | "sell" | "fee";
						/**
						 * Transaction sender address
						 */
						from?: string;
						/**
						 * Spender address for approval transactions
						 */
						spender?: string;
						/**
						 * Transaction value in wei
						 */
						value?: string;
					}>;
					/**
					 * Origin amount in wei
					 */
					originAmount: string;
					/**
					 * Destination amount in wei
					 */
					destinationAmount: string;
					/**
					 * Estimated execution time in milliseconds
					 */
					estimatedExecutionTimeMs?: number;
				}>;
				/**
				 * Quote timestamp
				 */
				timestamp: number;
			};
		};
	};
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type PaymentsPurchaseError =
	PaymentsPurchaseErrors[keyof PaymentsPurchaseErrors];

export type PaymentsPurchaseResponses = {
	/**
	 * Product purchased successfully. Returns the transaction used for the purchase.
	 */
	200: {
		result: {
			/**
			 * Transaction ID that was executed for your product purchase
			 */
			transactionId: string;
		};
	};
};

export type PaymentsPurchaseResponse =
	PaymentsPurchaseResponses[keyof PaymentsPurchaseResponses];

export type VerifyX402PaymentData = {
	/**
	 * Request body for x402 facilitator 'verify'
	 */
	body?: {
		paymentPayload: {
			x402Version: number;
			scheme: "exact";
			network:
				| "base-sepolia"
				| "base"
				| "avalanche-fuji"
				| "avalanche"
				| "iotex"
				| "solana-devnet"
				| "solana"
				| "sei"
				| "sei-testnet"
				| string;
			payload:
				| {
						signature: string;
						authorization: {
							from: string;
							to: string;
							value: string;
							validAfter: string;
							validBefore: string;
							nonce: string;
						};
				  }
				| {
						transaction: string;
				  };
		};
		paymentRequirements: {
			scheme: "exact";
			network:
				| "base-sepolia"
				| "base"
				| "avalanche-fuji"
				| "avalanche"
				| "iotex"
				| "solana-devnet"
				| "solana"
				| "sei"
				| "sei-testnet"
				| string;
			maxAmountRequired: string;
			resource: string;
			description: string;
			mimeType: string;
			outputSchema?: {
				[key: string]: unknown;
			};
			payTo: string;
			maxTimeoutSeconds: number;
			asset: string;
			extra?: {
				[key: string]: unknown;
			};
		};
	};
	path?: never;
	query?: never;
	url: "/v1/payments/x402/verify";
};

export type VerifyX402PaymentErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header.
	 */
	401: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type VerifyX402PaymentResponses = {
	/**
	 * Response returned by x402 facilitator 'verify'
	 */
	200: {
		isValid: boolean;
		invalidReason?:
			| "insufficient_funds"
			| "invalid_exact_evm_payload_authorization_valid_after"
			| "invalid_exact_evm_payload_authorization_valid_before"
			| "invalid_exact_evm_payload_authorization_value"
			| "invalid_exact_evm_payload_signature"
			| "invalid_exact_evm_payload_recipient_mismatch"
			| "invalid_exact_svm_payload_transaction"
			| "invalid_exact_svm_payload_transaction_amount_mismatch"
			| "invalid_exact_svm_payload_transaction_create_ata_instruction"
			| "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee"
			| "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset"
			| "invalid_exact_svm_payload_transaction_instructions"
			| "invalid_exact_svm_payload_transaction_instructions_length"
			| "invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction"
			| "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction"
			| "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high"
			| "invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked"
			| "invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked"
			| "invalid_exact_svm_payload_transaction_not_a_transfer_instruction"
			| "invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata"
			| "invalid_exact_svm_payload_transaction_receiver_ata_not_found"
			| "invalid_exact_svm_payload_transaction_sender_ata_not_found"
			| "invalid_exact_svm_payload_transaction_simulation_failed"
			| "invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata"
			| "invalid_network"
			| "invalid_payload"
			| "invalid_payment_requirements"
			| "invalid_scheme"
			| "invalid_payment"
			| "payment_expired"
			| "unsupported_scheme"
			| "invalid_x402_version"
			| "invalid_transaction_state"
			| "settle_exact_svm_block_height_exceeded"
			| "settle_exact_svm_transaction_confirmation_timed_out"
			| "unexpected_settle_error"
			| "unexpected_verify_error";
		payer?: string;
		errorMessage?: string;
	};
};

export type VerifyX402PaymentResponse =
	VerifyX402PaymentResponses[keyof VerifyX402PaymentResponses];

export type SettleX402PaymentData = {
	/**
	 * Request body for x402 facilitator 'settle'
	 */
	body?: {
		paymentPayload: {
			x402Version: number;
			scheme: "exact";
			network:
				| "base-sepolia"
				| "base"
				| "avalanche-fuji"
				| "avalanche"
				| "iotex"
				| "solana-devnet"
				| "solana"
				| "sei"
				| "sei-testnet"
				| string;
			payload:
				| {
						signature: string;
						authorization: {
							from: string;
							to: string;
							value: string;
							validAfter: string;
							validBefore: string;
							nonce: string;
						};
				  }
				| {
						transaction: string;
				  };
		};
		paymentRequirements: {
			scheme: "exact";
			network:
				| "base-sepolia"
				| "base"
				| "avalanche-fuji"
				| "avalanche"
				| "iotex"
				| "solana-devnet"
				| "solana"
				| "sei"
				| "sei-testnet"
				| string;
			maxAmountRequired: string;
			resource: string;
			description: string;
			mimeType: string;
			outputSchema?: {
				[key: string]: unknown;
			};
			payTo: string;
			maxTimeoutSeconds: number;
			asset: string;
			extra?: {
				[key: string]: unknown;
			};
		};
		/**
		 * The event to wait for to determina a transaction confirmation. 'simulated' will only simulate the transaction (fastest), 'submitted' will wait till the transaction is submitted, and 'confirmed' will wait for the transaction to be fully confirmed on chain (slowest). Defaults to 'confirmed'.
		 */
		waitUntil?: "simulated" | "submitted" | "confirmed";
	};
	path?: never;
	query?: never;
	url: "/v1/payments/x402/settle";
};

export type SettleX402PaymentErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header.
	 */
	401: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type SettleX402PaymentResponses = {
	/**
	 * Response returned by x402 facilitator 'settle'
	 */
	200: {
		success: boolean;
		errorReason?:
			| "insufficient_funds"
			| "invalid_exact_evm_payload_authorization_valid_after"
			| "invalid_exact_evm_payload_authorization_valid_before"
			| "invalid_exact_evm_payload_authorization_value"
			| "invalid_exact_evm_payload_signature"
			| "invalid_exact_evm_payload_recipient_mismatch"
			| "invalid_exact_svm_payload_transaction"
			| "invalid_exact_svm_payload_transaction_amount_mismatch"
			| "invalid_exact_svm_payload_transaction_create_ata_instruction"
			| "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee"
			| "invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset"
			| "invalid_exact_svm_payload_transaction_instructions"
			| "invalid_exact_svm_payload_transaction_instructions_length"
			| "invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction"
			| "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction"
			| "invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high"
			| "invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked"
			| "invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked"
			| "invalid_exact_svm_payload_transaction_not_a_transfer_instruction"
			| "invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata"
			| "invalid_exact_svm_payload_transaction_receiver_ata_not_found"
			| "invalid_exact_svm_payload_transaction_sender_ata_not_found"
			| "invalid_exact_svm_payload_transaction_simulation_failed"
			| "invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata"
			| "invalid_network"
			| "invalid_payload"
			| "invalid_payment_requirements"
			| "invalid_scheme"
			| "invalid_payment"
			| "payment_expired"
			| "unsupported_scheme"
			| "invalid_x402_version"
			| "invalid_transaction_state"
			| "settle_exact_svm_block_height_exceeded"
			| "settle_exact_svm_transaction_confirmation_timed_out"
			| "unexpected_settle_error"
			| "unexpected_verify_error";
		payer?: string;
		transaction: string;
		network:
			| "base-sepolia"
			| "base"
			| "avalanche-fuji"
			| "avalanche"
			| "iotex"
			| "solana-devnet"
			| "solana"
			| "sei"
			| "sei-testnet";
		errorMessage?: string;
	};
};

export type SettleX402PaymentResponse =
	SettleX402PaymentResponses[keyof SettleX402PaymentResponses];

export type SupportedX402PaymentsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		tokenAddress?: string;
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId?: number;
	};
	url: "/v1/payments/x402/supported";
};

export type SupportedX402PaymentsErrors = {
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header.
	 */
	401: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type SupportedX402PaymentsResponses = {
	/**
	 * Supported payment kinds for this facilitator
	 */
	200: {
		kinds: Array<{
			x402Version: 1;
			scheme: "exact";
			network:
				| "base-sepolia"
				| "base"
				| "avalanche-fuji"
				| "avalanche"
				| "iotex"
				| "solana-devnet"
				| "solana"
				| "sei"
				| "sei-testnet"
				| string;
			extra?: {
				defaultAsset?: {
					/**
					 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
					 */
					address: string;
					decimals: number;
					eip712: {
						name: string;
						version: string;
						primaryType: "TransferWithAuthorization" | "Permit";
					};
				};
				supportedAssets?: Array<{
					/**
					 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
					 */
					address: string;
					decimals: number;
					eip712: {
						name: string;
						version: string;
						primaryType: "TransferWithAuthorization" | "Permit";
					};
				}>;
			};
		}>;
	};
};

export type SupportedX402PaymentsResponse =
	SupportedX402PaymentsResponses[keyof SupportedX402PaymentsResponses];

export type FetchWithPaymentData = {
	/**
	 * Body
	 * Optional body to send to the target url if method is POST, PUT, PATCH, or DELETE. Should be a valid javascript object.
	 */
	body?: {
		[key: string]: unknown;
	};
	path?: never;
	query: {
		/**
		 * From
		 * The authenticated wallet address (server or user wallet)
		 */
		from?: string;
		/**
		 * URL
		 * The url to fetch
		 */
		url: string;
		/**
		 * Method
		 * The method to use, defaults to GET
		 */
		method?: "POST" | "PUT" | "DELETE" | "PATCH" | "GET";
		/**
		 * Max Value
		 * The maximum value to fetch in base units of the asset (e.g. 1000000 for 1 USDC)
		 */
		maxValue?: string;
		/**
		 * Asset
		 * The asset (token address) to use for the payment. If not provided, the asset from the url's payment requirements will be used.
		 */
		asset?: string;
		/**
		 * Chain ID
		 * The chain ID to use for the payment. If not provided, the chain ID from the url's payment requirements will be used.
		 */
		chainId?: number;
	};
	url: "/v1/payments/x402/fetch";
};

export type FetchWithPaymentErrors = {
	/**
	 * Invalid request parameters
	 */
	400: unknown;
	/**
	 * Authentication required. For frontend usage, include `x-client-id` and `Authorization: Bearer <jwt>` headers. For backend usage, include `x-secret-key` header.
	 */
	401: unknown;
	/**
	 * Payment Required Response
	 * Payment required response when user has insufficient funds. Contains a quote for completing the purchase.
	 */
	402: {
		result: {
			/**
			 * Message to display to the user
			 */
			message: string;
			/**
			 * Link to purchase the product
			 */
			link: string;
			/**
			 * Payment ID
			 */
			id: string;
			/**
			 * Bridge quote for completing the payment
			 */
			quote: {
				/**
				 * Block number when quote was generated
				 */
				blockNumber?: string;
				/**
				 * Destination amount in wei
				 */
				destinationAmount: string;
				/**
				 * Estimated execution time in milliseconds
				 */
				estimatedExecutionTimeMs?: number;
				/**
				 * Quote intent details
				 */
				intent: {
					/**
					 * The amount in wei
					 */
					amount: string;
					/**
					 * Destination chain ID
					 */
					destinationChainId: number;
					/**
					 * Destination token address
					 */
					destinationTokenAddress: string;
					/**
					 * Origin chain ID
					 */
					originChainId: number;
					/**
					 * Origin token address
					 */
					originTokenAddress: string;
					/**
					 * Receiver address
					 */
					receiver: string;
					/**
					 * Sender address
					 */
					sender: string;
				};
				/**
				 * Origin amount in wei
				 */
				originAmount: string;
				/**
				 * Array of steps to complete the bridge operation
				 */
				steps: Array<{
					/**
					 * Origin token information
					 */
					originToken: {
						/**
						 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
						 */
						chainId: number;
						/**
						 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
						 */
						address: string;
						decimals: number;
						symbol: string;
						iconUri?: string;
						/**
						 * Token price in different FIAT currencies.
						 */
						prices: {
							[key: string]: number;
						};
					};
					/**
					 * Destination token information
					 */
					destinationToken: {
						/**
						 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
						 */
						chainId: number;
						/**
						 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
						 */
						address: string;
						decimals: number;
						symbol: string;
						iconUri?: string;
						/**
						 * Token price in different FIAT currencies.
						 */
						prices: {
							[key: string]: number;
						};
					};
					/**
					 * Array of transactions for this step
					 */
					transactions: Array<{
						/**
						 * Blockchain network identifier
						 */
						chainId: number;
						/**
						 * Transaction recipient address
						 */
						to: string;
						/**
						 * Transaction data payload
						 */
						data: string;
						/**
						 * Type of action this transaction performs
						 */
						action: "approval" | "transfer" | "buy" | "sell" | "fee";
						/**
						 * Transaction sender address
						 */
						from?: string;
						/**
						 * Spender address for approval transactions
						 */
						spender?: string;
						/**
						 * Transaction value in wei
						 */
						value?: string;
					}>;
					/**
					 * Origin amount in wei
					 */
					originAmount: string;
					/**
					 * Destination amount in wei
					 */
					destinationAmount: string;
					/**
					 * Estimated execution time in milliseconds
					 */
					estimatedExecutionTimeMs?: number;
				}>;
				/**
				 * Quote timestamp
				 */
				timestamp: number;
			};
		};
	};
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type FetchWithPaymentError =
	FetchWithPaymentErrors[keyof FetchWithPaymentErrors];

export type FetchWithPaymentResponses = {
	/**
	 * Returns the final result from the API call
	 */
	200: unknown;
};

export type ListPayableServicesData = {
	body?: never;
	path?: never;
	query?: {
		limit?: number;
		offset?: number;
		query?: string;
		sortBy?:
			| "createdAt"
			| "totalRequests"
			| "totalVolume"
			| "price"
			| "uniqueBuyers";
		sortOrder?: "asc" | "desc";
	};
	url: "/v1/payments/x402/discovery/resources";
};

export type ListPayableServicesErrors = {
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header.
	 */
	401: unknown;
	/**
	 * Internal server error
	 */
	500: unknown;
};

export type ListPayableServicesResponses = {
	/**
	 * List of discovered x402 resources
	 */
	200: {
		x402Version: number;
		items: Array<{
			resource: string;
			type: "http";
			x402Version: number;
			accepts: Array<{
				scheme: "exact";
				network:
					| "base-sepolia"
					| "base"
					| "avalanche-fuji"
					| "avalanche"
					| "iotex"
					| "solana-devnet"
					| "solana"
					| "sei"
					| "sei-testnet"
					| string;
				maxAmountRequired: string;
				resource: string;
				description: string;
				mimeType: string;
				outputSchema?: {
					[key: string]: unknown;
				};
				payTo: string;
				maxTimeoutSeconds: number;
				asset: string;
				extra?: {
					[key: string]: unknown;
				};
			}>;
			lastUpdated: string;
			metadata?: {
				[key: string]: unknown;
			};
		}>;
		pagination: {
			limit: number;
			offset: number;
			total: number;
		};
	};
};

export type ListPayableServicesResponse =
	ListPayableServicesResponses[keyof ListPayableServicesResponses];

export type ListTokensData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Number of tokens to return per page (1-100).
		 */
		limit?: number;
		/**
		 * Page number for pagination, starting from 1.
		 */
		page?: number;
		/**
		 * Limit tokens to a specific chain.
		 */
		chainId?: number;
		/**
		 * Get a specific token by contract address
		 */
		tokenAddress?: string;
		/**
		 * Limit tokens to a specific symbol.
		 */
		symbol?: string;
		/**
		 * Limit tokens to a specific name.
		 */
		name?: string;
	};
	url: "/v1/tokens";
};

export type ListTokensErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type ListTokensResponses = {
	/**
	 * Tokens returned successfully.
	 */
	200: {
		pagination: {
			/**
			 * Whether there are more items available
			 */
			hasMore?: boolean;
			/**
			 * Number of items per page
			 */
			limit?: number;
			/**
			 * Current page number
			 */
			page?: number;
			/**
			 * Total number of items available
			 */
			totalCount?: number;
		};
		tokens: Array<{
			/**
			 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
			 */
			chainId: number;
			/**
			 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
			 */
			address: string;
			decimals: number;
			symbol: string;
			iconUri?: string;
			/**
			 * Token price in different FIAT currencies.
			 */
			prices: {
				[key: string]: number;
			};
		}>;
	};
};

export type ListTokensResponse = ListTokensResponses[keyof ListTokensResponses];

export type CreateTokenData = {
	/**
	 * Request schema for creating a new ERC20 token
	 */
	body?: {
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
		/**
		 * Token name
		 */
		name: string;
		/**
		 * Token symbol
		 */
		symbol: string;
		/**
		 * Token description
		 */
		description: string;
		/**
		 * Token image URL
		 */
		imageUrl: string;
		/**
		 * Wallet address or ENS that will deploy the token. If omitted, the project wallet will be used if available.
		 */
		from?: string;
		/**
		 * The token owner address, if different from `from`.
		 */
		owner?: string;
		/**
		 * A salt to deterministically generate the token address.
		 */
		salt?: string;
		/**
		 * The maximum token supply.
		 */
		maxSupply?: number;
		/**
		 * Setup this token for a sale.
		 */
		sale?: {
			type?: "pool";
			/**
			 * The initial token price in wei. This price is in the currency specified by `currency` (or the native token if not specified).
			 */
			startingPrice: string;
			/**
			 * The number of tokens to allocate to the sale.
			 */
			amount: number;
			/**
			 * The bps fee on the token pool.
			 */
			developerFeeBps?: number;
			/**
			 * The address to send the developer fee to. Defaults to the token owner.
			 */
			developerFeeRecipient?: string;
			/**
			 * The currency to price this token sale in. Defaults to the native token.
			 */
			currency?: string;
		};
	};
	path?: never;
	query?: never;
	url: "/v1/tokens";
};

export type CreateTokenErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment required. Insufficient wallet balance to deploy the contract.
	 */
	402: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type CreateTokenResponses = {
	/**
	 * The token is being deployed. Returns the predicted token address.
	 */
	202: {
		/**
		 * The in-progress deployment transaction ID.
		 */
		transactionId: string;
		/**
		 * The address the token was deployed at
		 */
		address: string;
	};
};

export type CreateTokenResponse =
	CreateTokenResponses[keyof CreateTokenResponses];

export type GetTokenOwnersData = {
	body?: never;
	path: {
		/**
		 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
		 */
		chainId: number;
		/**
		 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
		 */
		address: string;
	};
	query?: {
		/**
		 * Optional token ID for NFT owners. If provided, returns owners of the specific NFT token.
		 */
		tokenId?: string;
		/**
		 * Number of owners to return per page (1-100).
		 */
		limit?: number;
		/**
		 * Page number for pagination, starting from 1.
		 */
		page?: number;
	};
	url: "/v1/tokens/{chainId}/{address}/owners";
};

export type GetTokenOwnersErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. The request must include a valid `x-client-id` header for frontend usage or `x-secret-key` for backend usage.
	 */
	401: unknown;
	/**
	 * Token not found or no owners available.
	 */
	404: unknown;
	/**
	 * Internal server error.
	 */
	500: unknown;
};

export type GetTokenOwnersResponses = {
	/**
	 * Token owners retrieved successfully. Returns owners with pagination information. For ERC-20 tokens, `amount` represents token balance. For NFTs, `amount` represents quantity owned (usually '1' for ERC-721, can be >1 for ERC-1155).
	 */
	200: {
		result: {
			/**
			 * Array of token owners with amounts.
			 */
			owners: Array<{
				/**
				 * Owner wallet address
				 */
				address: string;
				/**
				 * Token amount owned as a string
				 */
				amount: string;
				/**
				 * Token ID for NFTs
				 */
				tokenId?: string;
			}>;
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetTokenOwnersResponse =
	GetTokenOwnersResponses[keyof GetTokenOwnersResponses];

export type GetBridgeChainsData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/v1/bridge/chains";
};

export type GetBridgeChainsErrors = {
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` header.
	 */
	401: unknown;
	/**
	 * Internal server error occurred while fetching bridge chains.
	 */
	500: unknown;
};

export type GetBridgeChainsResponses = {
	/**
	 * Successfully retrieved supported bridge chains.
	 */
	200: {
		/**
		 * Blockchain networks that support cross-chain bridging
		 */
		result: Array<{
			/**
			 * The chain ID of the chain
			 */
			chainId: number;
			/**
			 * The name of the chain
			 */
			name: string;
			/**
			 * The URL of the chain's icon
			 */
			icon: string;
			/**
			 * Information about the native currency of the chain
			 */
			nativeCurrency: {
				/**
				 * The name of the native currency
				 */
				name: string;
				/**
				 * The symbol of the native currency
				 */
				symbol: string;
				/**
				 * The number of decimals used by the native currency
				 */
				decimals: number;
			};
		}>;
	};
};

export type GetBridgeChainsResponse =
	GetBridgeChainsResponses[keyof GetBridgeChainsResponses];

export type GetBridgeSupportedRoutesData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Maximum number of routes to return (1-100).
		 */
		limit?: number;
		/**
		 * Page number for pagination, starting at 1.
		 */
		page?: number;
		/**
		 * Filter routes by the origin chain ID.
		 */
		originChainId?: number;
		/**
		 * Filter routes by the destination chain ID.
		 */
		destinationChainId?: number;
		/**
		 * Filter routes by origin token address.
		 */
		originTokenAddress?: string;
		/**
		 * Filter routes by destination token address.
		 */
		destinationTokenAddress?: string;
		/**
		 * Maximum number of bridge steps allowed in the route.
		 */
		maxSteps?: number;
	};
	url: "/v1/bridge/routes";
};

export type GetBridgeSupportedRoutesErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` header.
	 */
	401: unknown;
	/**
	 * Internal server error occurred while fetching bridge routes.
	 */
	500: unknown;
};

export type GetBridgeSupportedRoutesResponses = {
	/**
	 * Successfully retrieved supported bridge routes.
	 */
	200: {
		result: {
			/**
			 * Supported bridge routes that match the provided filters.
			 */
			routes: Array<{
				originToken: {
					/**
					 * Chain identifier for the token
					 */
					chainId: number;
					/**
					 * Token contract address
					 */
					address: string;
					/**
					 * Token symbol
					 */
					symbol: string;
					/**
					 * Token name
					 */
					name: string;
					/**
					 * Number of decimals the token uses
					 */
					decimals: number;
					/**
					 * Optional icon URL for the token
					 */
					iconUri?: string;
					/**
					 * 24h market capitalization in USD when available
					 */
					marketCapUsd?: number;
					/**
					 * 24h trading volume in USD when available
					 */
					volume24hUsd?: number;
					/**
					 * Token price quotes keyed by fiat currency code
					 */
					prices?: {
						[key: string]: number;
					};
				};
				destinationToken: {
					/**
					 * Chain identifier for the token
					 */
					chainId: number;
					/**
					 * Token contract address
					 */
					address: string;
					/**
					 * Token symbol
					 */
					symbol: string;
					/**
					 * Token name
					 */
					name: string;
					/**
					 * Number of decimals the token uses
					 */
					decimals: number;
					/**
					 * Optional icon URL for the token
					 */
					iconUri?: string;
					/**
					 * 24h market capitalization in USD when available
					 */
					marketCapUsd?: number;
					/**
					 * 24h trading volume in USD when available
					 */
					volume24hUsd?: number;
					/**
					 * Token price quotes keyed by fiat currency code
					 */
					prices?: {
						[key: string]: number;
					};
				};
			}>;
			/**
			 * Pagination details for the returned routes.
			 */
			pagination: {
				/**
				 * Whether there are more items available
				 */
				hasMore?: boolean;
				/**
				 * Number of items per page
				 */
				limit?: number;
				/**
				 * Current page number
				 */
				page?: number;
				/**
				 * Total number of items available
				 */
				totalCount?: number;
			};
		};
	};
};

export type GetBridgeSupportedRoutesResponse =
	GetBridgeSupportedRoutesResponses[keyof GetBridgeSupportedRoutesResponses];

export type ConvertFiatToCryptoData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The fiat currency symbol
		 */
		from:
			| "USD"
			| "EUR"
			| "GBP"
			| "JPY"
			| "KRW"
			| "CNY"
			| "INR"
			| "NOK"
			| "SEK"
			| "CHF"
			| "AUD"
			| "CAD"
			| "NZD"
			| "MXN"
			| "BRL"
			| "CLP"
			| "CZK"
			| "DKK"
			| "HKD"
			| "HUF"
			| "IDR"
			| "ILS"
			| "ISK";
		/**
		 * The amount of fiat currency to convert
		 */
		fromAmount: string;
		/**
		 * The blockchain network identifier
		 */
		chainId: number;
		/**
		 * The token address on the specified chain to convert to
		 */
		to: string;
	};
	url: "/v1/bridge/convert";
};

export type ConvertFiatToCryptoErrors = {
	/**
	 * Bad request. Invalid parameters such as invalid amounts, malformed token address, or invalid currency code.
	 */
	400: unknown;
	/**
	 * Authentication required. Include `x-client-id` header for frontend usage or `x-secret-key` for backend usage.
	 */
	401: unknown;
	/**
	 * Token not found, price data unavailable for the specified token on the given chain, or price data not available for the requested currency.
	 */
	404: unknown;
	/**
	 * Too many requests. Rate limit exceeded.
	 */
	429: unknown;
	/**
	 * Internal server error. This may occur due to network connectivity issues or external service failures.
	 */
	500: unknown;
};

export type ConvertFiatToCryptoResponses = {
	/**
	 * Conversion completed successfully. Returns the amount of crypto tokens equivalent to the specified fiat amount.
	 */
	200: {
		/**
		 * The conversion result - amount of crypto tokens for the fiat amount
		 */
		result: number;
	};
};

export type ConvertFiatToCryptoResponse =
	ConvertFiatToCryptoResponses[keyof ConvertFiatToCryptoResponses];

export type BridgeSwapData = {
	/**
	 * Swap Token Request
	 * Request to swap tokens using the optimal route available. You can specify a tokenIn amount (if exact='input') or tokenOut amount (if exact='output'), but not both. The corresponding output or input amount will be returned as the quote.
	 */
	body?: {
		/**
		 * Whether to swap the exact input or output amount
		 */
		exact?: "input" | "output";
		tokenIn: {
			/**
			 * The input token address to swap (use 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native token)
			 */
			address: string;
			/**
			 * The blockchain network where the token is located
			 */
			chainId: number;
			/**
			 * The amount of the input token to swap in wei.
			 */
			amount?: string;
			/**
			 * The maximum amount of the input token to swap in wei.
			 */
			maxAmount?: string;
		};
		tokenOut: {
			/**
			 * The output token address to swap (use 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE for native token)
			 */
			address: string;
			/**
			 * The blockchain network where the token is located
			 */
			chainId: number;
			/**
			 * The amount of the output token to receive in wei.
			 */
			amount?: string;
			/**
			 * The minimum amount of the output token to receive in wei.
			 */
			minAmount?: string;
		};
		/**
		 * The wallet address or ENS name that will execute the swap. If omitted, the project wallet will be used if available.
		 */
		from?: string;
		/**
		 * The slippage tolerance in basis points. Will be automatically calculated by default.
		 */
		slippageToleranceBps?: number;
	};
	path?: never;
	query?: never;
	url: "/v1/bridge/swap";
};

export type BridgeSwapErrors = {
	/**
	 * Invalid request parameters.
	 */
	400: unknown;
	/**
	 * Authentication required. For backend usage, include `x-secret-key` header. For frontend usage, include `x-client-id` + `Authorization: Bearer <jwt>` headers.
	 */
	401: unknown;
	/**
	 * Payment Required Response
	 * Payment required response when user has insufficient funds. Contains a quote for completing the purchase.
	 */
	402: {
		result: {
			/**
			 * Message to display to the user
			 */
			message: string;
			/**
			 * Link to purchase the product
			 */
			link: string;
			/**
			 * Payment ID
			 */
			id: string;
			/**
			 * Bridge quote for completing the payment
			 */
			quote: {
				/**
				 * Block number when quote was generated
				 */
				blockNumber?: string;
				/**
				 * Destination amount in wei
				 */
				destinationAmount: string;
				/**
				 * Estimated execution time in milliseconds
				 */
				estimatedExecutionTimeMs?: number;
				/**
				 * Quote intent details
				 */
				intent: {
					/**
					 * The amount in wei
					 */
					amount: string;
					/**
					 * Destination chain ID
					 */
					destinationChainId: number;
					/**
					 * Destination token address
					 */
					destinationTokenAddress: string;
					/**
					 * Origin chain ID
					 */
					originChainId: number;
					/**
					 * Origin token address
					 */
					originTokenAddress: string;
					/**
					 * Receiver address
					 */
					receiver: string;
					/**
					 * Sender address
					 */
					sender: string;
				};
				/**
				 * Origin amount in wei
				 */
				originAmount: string;
				/**
				 * Array of steps to complete the bridge operation
				 */
				steps: Array<{
					/**
					 * Origin token information
					 */
					originToken: {
						/**
						 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
						 */
						chainId: number;
						/**
						 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
						 */
						address: string;
						decimals: number;
						symbol: string;
						iconUri?: string;
						/**
						 * Token price in different FIAT currencies.
						 */
						prices: {
							[key: string]: number;
						};
					};
					/**
					 * Destination token information
					 */
					destinationToken: {
						/**
						 * The blockchain network identifier. Common values include: 1 (Ethereum), 8453 (Base), 137 (Polygon), 56 (BSC), 43114 (Avalanche), 42161 (Arbitrum), 10 (Optimism).
						 */
						chainId: number;
						/**
						 * A valid Ethereum address (0x-prefixed hex string) or ENS name (e.g., vitalik.eth).
						 */
						address: string;
						decimals: number;
						symbol: string;
						iconUri?: string;
						/**
						 * Token price in different FIAT currencies.
						 */
						prices: {
							[key: string]: number;
						};
					};
					/**
					 * Array of transactions for this step
					 */
					transactions: Array<{
						/**
						 * Blockchain network identifier
						 */
						chainId: number;
						/**
						 * Transaction recipient address
						 */
						to: string;
						/**
						 * Transaction data payload
						 */
						data: string;
						/**
						 * Type of action this transaction performs
						 */
						action: "approval" | "transfer" | "buy" | "sell" | "fee";
						/**
						 * Transaction sender address
						 */
						from?: string;
						/**
						 * Spender address for approval transactions
						 */
						spender?: string;
						/**
						 * Transaction value in wei
						 */
						value?: string;
					}>;
					/**
					 * Origin amount in wei
					 */
					originAmount: string;
					/**
					 * Destination amount in wei
					 */
					destinationAmount: string;
					/**
					 * Estimated execution time in milliseconds
					 */
					estimatedExecutionTimeMs?: number;
				}>;
				/**
				 * Quote timestamp
				 */
				timestamp: number;
			};
		};
	};
	/**
	 * Internal server error. This may occur due to network connectivity issues, wallet creation failures, or transaction execution failures.
	 */
	500: unknown;
};

export type BridgeSwapError = BridgeSwapErrors[keyof BridgeSwapErrors];

export type BridgeSwapResponses = {
	/**
	 * Swap Token Response
	 * Successful token swap response containing executed transaction ID
	 */
	200: {
		result: {
			/**
			 * Payment transaction ID that was executed
			 */
			transactionId: string;
		};
	};
};

export type BridgeSwapResponse = BridgeSwapResponses[keyof BridgeSwapResponses];

export type ListSolanaWalletsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Page number for paginated results. Starts at 1.
		 */
		page?: number;
		/**
		 * Maximum number of wallets to return per page.
		 */
		limit?: number;
	};
	url: "/v1/solana/wallets";
};

export type ListSolanaWalletsErrors = {
	/**
	 * Authentication required. Include x-secret-key or Authorization headers.
	 */
	401: unknown;
	/**
	 * Internal server error occurred while listing wallets.
	 */
	500: unknown;
};

export type ListSolanaWalletsResponses = {
	/**
	 * Successfully retrieved Solana wallets with pagination metadata.
	 */
	200: {
		result: {
			/**
			 * Array of Solana wallets created for your project.
			 */
			wallets: Array<{
				/**
				 * Base58 encoded Solana address.
				 */
				address: string;
				/**
				 * Optional label associated with the wallet.
				 */
				label?: string;
				/**
				 * ISO 8601 timestamp indicating when the wallet was created.
				 */
				createdAt: string;
				/**
				 * ISO 8601 timestamp indicating when the wallet was last updated.
				 */
				updatedAt: string;
			}>;
			/**
			 * Pagination details for the wallet list.
			 */
			pagination: {
				/**
				 * Total number of wallets available.
				 */
				totalCount: number;
				/**
				 * Current page number.
				 */
				page: number;
				/**
				 * Number of wallets returned per page.
				 */
				limit: number;
			};
		};
	};
};

export type ListSolanaWalletsResponse =
	ListSolanaWalletsResponses[keyof ListSolanaWalletsResponses];

export type CreateSolanaWalletData = {
	/**
	 * Request payload for creating or fetching a Solana wallet by label.
	 */
	body?: {
		/**
		 * Unique label to identify the wallet. Used for retrieval and management.
		 */
		label: string;
	};
	path?: never;
	query?: never;
	url: "/v1/solana/wallets";
};

export type CreateSolanaWalletErrors = {
	/**
	 * Authentication required. Include x-secret-key or Authorization headers.
	 */
	401: unknown;
	/**
	 * Internal server error occurred while creating wallet.
	 */
	500: unknown;
};

export type CreateSolanaWalletResponses = {
	/**
	 * Solana wallet retrieved for the provided label.
	 */
	200: {
		/**
		 * Details for a Solana wallet in your project.
		 */
		result: {
			/**
			 * Base58 encoded Solana address.
			 */
			address: string;
			/**
			 * Optional label associated with the wallet.
			 */
			label?: string;
			/**
			 * ISO 8601 timestamp indicating when the wallet was created.
			 */
			createdAt: string;
			/**
			 * ISO 8601 timestamp indicating when the wallet was last updated.
			 */
			updatedAt: string;
		};
	};
	/**
	 * Solana wallet created for the provided label.
	 */
	201: {
		/**
		 * Details for a Solana wallet in your project.
		 */
		result: {
			/**
			 * Base58 encoded Solana address.
			 */
			address: string;
			/**
			 * Optional label associated with the wallet.
			 */
			label?: string;
			/**
			 * ISO 8601 timestamp indicating when the wallet was created.
			 */
			createdAt: string;
			/**
			 * ISO 8601 timestamp indicating when the wallet was last updated.
			 */
			updatedAt: string;
		};
	};
};

export type CreateSolanaWalletResponse =
	CreateSolanaWalletResponses[keyof CreateSolanaWalletResponses];

export type SignSolanaMessageData = {
	/**
	 * Request payload for signing an arbitrary Solana message.
	 */
	body?: {
		/**
		 * The Solana wallet address used for signing.
		 */
		from: string;
		/**
		 * Message to sign. Can be plain text or hexadecimal format (starting with 0x). The format is automatically detected.
		 */
		message: string;
	};
	path?: never;
	query?: never;
	url: "/v1/solana/sign-message";
};

export type SignSolanaMessageErrors = {
	/**
	 * Authentication required. Include x-secret-key or Authorization headers.
	 */
	401: unknown;
	/**
	 * Internal server error occurred while signing the message.
	 */
	500: unknown;
};

export type SignSolanaMessageResponses = {
	/**
	 * Message signed successfully. Returns the base58 signature.
	 */
	200: {
		result: {
			/**
			 * Base58 encoded signature returned from the signer.
			 */
			signature: string;
		};
	};
};

export type SignSolanaMessageResponse =
	SignSolanaMessageResponses[keyof SignSolanaMessageResponses];

export type SendSolanaTokensData = {
	/**
	 * Request payload for transferring SOL or SPL tokens on Solana.
	 */
	body?: {
		/**
		 * Solana wallet address that will sign and submit the transfer.
		 */
		from: string;
		/**
		 * Destination Solana address.
		 */
		to: string;
		/**
		 * Amount to transfer expressed in base units (lamports for SOL or token decimals).
		 */
		amount: string;
		/**
		 * Solana network identifier. Use solana:devnet for testing and solana:mainnet for production.
		 */
		chainId: "solana:mainnet" | "solana:devnet";
		/**
		 * Optional SPL token mint address. When omitted a native SOL transfer is performed.
		 */
		tokenAddress?: string;
	};
	path?: never;
	query?: never;
	url: "/v1/solana/send";
};

export type SendSolanaTokensErrors = {
	/**
	 * Authentication required. Include x-secret-key or Authorization headers.
	 */
	401: unknown;
	/**
	 * Internal server error occurred while processing the transfer.
	 */
	500: unknown;
};

export type SendSolanaTokensResponses = {
	/**
	 * Transfer queued successfully. Returns the transaction identifier for status polling.
	 */
	200: {
		result: {
			/**
			 * Idempotency key assigned to the queued transaction.
			 */
			transactionId: string;
		};
	};
	/**
	 * Transfer accepted for asynchronous processing. Returns the transaction identifier for status polling.
	 */
	202: {
		result: {
			/**
			 * Idempotency key assigned to the queued transaction.
			 */
			transactionId: string;
		};
	};
};

export type SendSolanaTokensResponse =
	SendSolanaTokensResponses[keyof SendSolanaTokensResponses];

export type SendSolanaTransactionData = {
	/**
	 * Submit a Solana transaction made up of one or more instructions.
	 */
	body?: {
		/**
		 * Solana wallet address that will sign and submit the transaction.
		 */
		from: string;
		/**
		 * Solana network identifier. Use solana:devnet for testing and solana:mainnet for production.
		 */
		chainId: "solana:mainnet" | "solana:devnet";
		/**
		 * Set of instructions executed sequentially in a single transaction.
		 */
		transactions: Array<{
			/**
			 * Program address to invoke for this instruction.
			 */
			programId: string;
			/**
			 * Ordered list of accounts consumed by the instruction.
			 */
			accounts: Array<{
				/**
				 * Public key for the account.
				 */
				address: string;
				/**
				 * Whether this account must sign the transaction.
				 */
				isSigner: boolean;
				/**
				 * Whether this account can be modified by the instruction.
				 */
				isWritable: boolean;
			}>;
			/**
			 * Instruction data encoded using the provided encoding.
			 */
			data: string;
			/**
			 * Encoding used for the instruction data payload.
			 */
			encoding?: "hex" | "base64";
		}>;
	};
	path?: never;
	query?: never;
	url: "/v1/solana/transactions";
};

export type SendSolanaTransactionErrors = {
	/**
	 * Authentication required. Include x-secret-key or Authorization headers.
	 */
	401: unknown;
	/**
	 * Internal server error occurred while processing the transaction.
	 */
	500: unknown;
};

export type SendSolanaTransactionResponses = {
	/**
	 * Transaction queued successfully. Returns the transaction identifier for status polling.
	 */
	200: {
		result: {
			/**
			 * Idempotency key assigned to the queued transaction.
			 */
			transactionId: string;
		};
	};
	/**
	 * Transaction accepted for asynchronous processing. Returns the transaction identifier for status polling.
	 */
	202: {
		result: {
			/**
			 * Idempotency key assigned to the queued transaction.
			 */
			transactionId: string;
		};
	};
};

export type SendSolanaTransactionResponse =
	SendSolanaTransactionResponses[keyof SendSolanaTransactionResponses];

export type GetSolanaTransactionData = {
	body?: never;
	path: {
		/**
		 * Identifier returned when the transaction was queued.
		 */
		transactionId: string;
	};
	query?: never;
	url: "/v1/solana/transactions/:transactionId";
};

export type GetSolanaTransactionErrors = {
	/**
	 * Authentication required. Include x-secret-key or Authorization headers.
	 */
	401: unknown;
	/**
	 * Transaction not found. The identifier may be invalid or expired.
	 */
	404: unknown;
	/**
	 * Internal server error occurred while fetching transaction status.
	 */
	500: unknown;
};

export type GetSolanaTransactionResponses = {
	/**
	 * Transaction status retrieved successfully.
	 */
	200: {
		/**
		 * Transaction metadata and status information.
		 */
		result: {
			/**
			 * Unique identifier for the transaction.
			 */
			id: string;
			/**
			 * Solana network identifier. Use solana:devnet for testing and solana:mainnet for production.
			 */
			chainId: "solana:mainnet" | "solana:devnet";
			/**
			 * Signer address used on submission.
			 */
			from: string;
			/**
			 * Signature recorded on-chain once available.
			 */
			signature?: string;
			/**
			 * Current status of the transaction in the processing pipeline.
			 */
			status?: "QUEUED" | "SUBMITTED" | "CONFIRMED" | "FAILED";
			/**
			 * Timestamp when the transaction reached the reported status.
			 */
			confirmedAt?: string;
			/**
			 * Slot where the transaction was confirmed, if available.
			 */
			confirmedAtSlot?: string;
			/**
			 * Unix timestamp of the processed block.
			 */
			blockTime?: number;
			/**
			 * ISO 8601 timestamp when the transaction was queued.
			 */
			createdAt: string;
			/**
			 * Error message if the transaction failed.
			 */
			errorMessage?: string;
			/**
			 * Resolved execution parameters used for the transaction.
			 */
			executionParams?: unknown;
			/**
			 * Raw execution result payload, if present.
			 */
			executionResult?: unknown;
			/**
			 * Original instruction payload submitted.
			 */
			transactionParams?: unknown;
			/**
			 * Project client identifier.
			 */
			clientId: string;
			enrichedData?: unknown;
			cancelledAt?: string;
		};
	};
};

export type GetSolanaTransactionResponse =
	GetSolanaTransactionResponses[keyof GetSolanaTransactionResponses];

export type ChatData = {
	/**
	 * Chat Request
	 * Chat request
	 */
	body?: {
		/**
		 * Natural language query for the AI assistant
		 */
		messages: Array<{
			role: "user" | "assistant" | "system" | "tool";
			content:
				| string
				| Array<
						| {
								type: "image";
								image_url?: string;
								b64?: string;
						  }
						| {
								type: "text";
								text: string;
						  }
						| {
								type: "transaction";
								chain_id: number;
								transaction_hash: string;
						  }
				  >;
		}>;
		/**
		 * Context for the AI assistant
		 */
		context?: {
			/**
			 * Optional wallet address that will execute transactions
			 */
			from?: string;
			/**
			 * Optional chain IDs for context
			 */
			chain_ids?: Array<number>;
			/**
			 * Optional session ID for conversation continuity. If not provided, a new session will be created
			 */
			session_id?: string;
			/**
			 * Whether to automatically execute transactions. If not provided, the default is false
			 */
			auto_execute_transactions?: boolean;
		};
		/**
		 * Enable server streaming of the AI response
		 */
		stream?: boolean;
	};
	path?: never;
	query?: never;
	url: "/ai/chat";
};

export type ChatResponses = {
	/**
	 * Chat Response
	 * Chat response
	 */
	200: {
		/**
		 * The AI assistant's response
		 */
		message: string;
		actions: Array<
			| {
					session_id: string;
					request_id: string;
					source?: string;
					type: "sign_transaction";
					data: {
						chain_id: number;
						function?: string;
						to: string;
						value: string;
						data: string;
					};
			  }
			| {
					session_id: string;
					request_id: string;
					source?: string;
					type: "sign_swap";
					data: {
						transaction: {
							chain_id: number;
							function?: string;
							to: string;
							value: string;
							data: string;
						};
						action: string;
						intent: {
							origin_chain_id: number;
							origin_token_address: string;
							destination_chain_id: number;
							destination_token_address: string;
							amount: string;
							sender: string;
							receiver: string;
							maxSteps: number;
						};
						from_token: {
							address: string;
							chain_id: number;
							amount: string;
							symbol: string;
							decimals: number;
							price: number;
						};
						to_token: {
							address: string;
							chain_id: number;
							amount: string;
							symbol: string;
							decimals: number;
							price: number;
						};
					};
			  }
			| {
					session_id: string;
					request_id: string;
					source?: string;
					type: "monitor_transaction";
					data: {
						transaction_id: string;
					};
			  }
		>;
		session_id: string;
		request_id: string;
	};
};

export type ChatResponse = ChatResponses[keyof ChatResponses];

export type McpServerData = {
	body?: unknown;
	path?: never;
	query?: {
		/**
		 * Comma-separated list of tools to request. Maps to the operationId of the OpenAPI endpoint. Example: ?tools=getWalletBalance,fetchWithPayment. If not provided, all tools will be returned.
		 */
		tools?: string;
	};
	url: "/mcp";
};

export type McpServerResponses = {
	/**
	 * MCP response
	 */
	200: unknown;
};

export type LlmsTxtData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/llms.txt";
};

export type LlmsTxtResponses = {
	/**
	 * LLMs.txt
	 */
	200: string;
};

export type LlmsTxtResponse = LlmsTxtResponses[keyof LlmsTxtResponses];

export type ClientOptions = {
	baseUrl: "https://api.thirdweb.com" | (string & {});
};
