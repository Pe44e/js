import {
  Callout,
  createMetadata,
  Tabs,
  TabsList,
  TabsTrigger,
  TabsContent,
  ArticleIconCard,
  DocImage
} from "@doc";
import {
  ReactIcon,
  TypeScriptIcon,
} from "@/icons";
import SwapWidgetImage from "./swap-dark.png";

export const metadata = createMetadata({
  image: {
    title: "Swap Tokens",
    icon: "payments",
  },
  title: "Swap Tokens",
  description: "Build a custom token swap interface using thirdweb Payments.",
});

# Swap Tokens


<Tabs defaultValue="react">
  <TabsList>
    <TabsTrigger value="react" className="flex items-center gap-2 [&>p]:mb-0">
      <ReactIcon className="w-4 h-4" />
      React
    </TabsTrigger>
    <TabsTrigger value="typescript" className="flex items-center gap-2 [&>p]:mb-0">
      <TypeScriptIcon className="w-4 h-4" />
      TypeScript
    </TabsTrigger>
  </TabsList>

<TabsContent value="react">

You can use the [`SwapWidget`](/references/typescript/v5/SwapWidget) component to easily integrate a token swap interface into your app


```tsx
import { SwapWidget } from "thirdweb/react";

const client = createThirdwebClient({
  clientId: "YOUR_CLIENT_ID",
});

function Example() {
  return <SwapWidget client={client} />;
}
```

<DocImage src={SwapWidgetImage} />

## Live Playground

<ArticleIconCard
  title="Swap Widget Playground"
  description="Try out the Swap Widget in our live playground"
  icon={ReactIcon}
  href="https://playground.thirdweb.com/bridge/swap-widget"
/>


### Configuring default token selection

By default, no tokens are selected in the widget UI. You can configure the default token selection for the swap widget by passing in the `prefill` prop.
it only sets the default token selection, User can change these selections in the widget UI


#### Set an ERC20 token to Buy by default

```tsx
<SwapWidget client={client} prefill={{
  buyToken: {
    // Base USDC
    chainId: 8453,
    tokenAddress: "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",
  },
}} />
```

#### Set a native token to Sell by default

To configure a native token to sell by default, you can omit the `tokenAddress` property.

```tsx
<SwapWidget client={client} prefill={{
  // Base native token (ETH)
  sellToken: {
    chainId: 8453,
  },
}} />
```

#### Set amount and token to Buy by default

```tsx
<SwapWidget client={client} prefill={{
  buyToken: {
    chainId: 8453,
    amount: "0.1",
    tokenAddress: "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",
  },
}} />
```

#### Set both buy and sell tokens by default

```tsx
<SwapWidget client={client} prefill={{
  // Base USDC
  buyToken: {
    chainId: 8453,
    tokenAddress: "0x833589fcd6edb6e08f4c7c32d4f71b54bda02913",
  },
  // Polygon native token (MATIC)
  sellToken: {
    chainId: 137,
  },
}} />
```






</TabsContent>

<TabsContent value="typescript">

### Core Swap Logic

Create the core swap functionality that can be integrated into any UI:

```typescript
import { Bridge, sendAndConfirmTransaction, type Account } from "thirdweb";

interface SwapParams {
  fromChainId: number;
  fromTokenAddress: string;
  toChainId: number;
  toTokenAddress: string;
  amount: bigint;
  userAddress: string;
  client: any;
}

interface SwapQuote {
  originAmount: bigint;
  destinationAmount: bigint;
  estimatedExecutionTimeMs: number;
  steps: any[];
}

export class SwapManager {
  private client: any;

  constructor(client: any) {
    this.client = client;
  }

  async getQuote(params: SwapParams): Promise<SwapQuote> {
    try {
      const quote = await Bridge.Buy.prepare({
        originChainId: params.fromChainId,
        originTokenAddress: params.fromTokenAddress,
        destinationChainId: params.toChainId,
        destinationTokenAddress: params.toTokenAddress,
        amount: params.amount,
        sender: params.userAddress,
        receiver: params.userAddress,
        client: this.client,
      });

      return {
        originAmount: quote.originAmount,
        destinationAmount: quote.destinationAmount,
        estimatedExecutionTimeMs: quote.estimatedExecutionTimeMs,
        steps: quote.steps,
      };
    } catch (error) {
      throw new Error(`Failed to get swap quote: ${error.message}`);
    }
  }

  async executeSwap(quote: SwapQuote, account: Account): Promise<string[]> {
    const transactionHashes: string[] = [];

    try {
      for (const step of quote.steps) {
        for (const transaction of step.transactions) {
          const result = await sendAndConfirmTransaction({
            transaction,
            account,
          });

          transactionHashes.push(result.transactionHash);

          // Wait for cross-chain completion if needed
          if (["buy", "sell", "transfer"].includes(transaction.action)) {
            await this.waitForCompletion(result.transactionHash, transaction.chainId);
          }
        }
      }

      return transactionHashes;
    } catch (error) {
      throw new Error(`Swap execution failed: ${error.message}`);
    }
  }

  private async waitForCompletion(transactionHash: string, chainId: number): Promise<void> {
    let attempts = 0;
    const maxAttempts = 200; // 10 minutes max wait

    while (attempts < maxAttempts) {
      try {
        const status = await Bridge.status({
          transactionHash,
          chainId,
          client: this.client,
        });

        if (status.status === "COMPLETED") {
          return;
        }

        if (status.status === "FAILED") {
          throw new Error("Cross-chain transaction failed");
        }

        // Wait 3 seconds before checking again
        await new Promise(resolve => setTimeout(resolve, 3000));
        attempts++;
      } catch (error) {
        attempts++;
        if (attempts >= maxAttempts) {
          throw error;
        }
      }
    }

    throw new Error("Transaction timeout - please check status manually");
  }

  async getAvailableRoutes(params: {
    originChainId?: number;
    originTokenAddress?: string;
    destinationChainId?: number;
    destinationTokenAddress?: string;
    limit?: number;
  }) {
    try {
      return await Bridge.routes({
        ...params,
        client: this.client,
      });
    } catch (error) {
      throw new Error(`Failed to get routes: ${error.message}`);
    }
  }
}
```

### Usage Example

```typescript
import { createThirdwebClient } from "thirdweb";
import { ethereum, polygon } from "thirdweb/chains";

const client = createThirdwebClient({
  clientId: "YOUR_CLIENT_ID",
});

const swapManager = new SwapManager(client);

// Example: Swap ETH to MATIC
async function swapEthToMatic(amount: string, userAccount: Account) {
  try {
    // Get quote
    const quote = await swapManager.getQuote({
      fromChainId: ethereum.id,
      fromTokenAddress: "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE", // ETH
      toChainId: polygon.id,
      toTokenAddress: "0x0000000000000000000000000000000000001010", // MATIC
      amount: BigInt(parseFloat(amount) * 1e18),
      userAddress: userAccount.address,
      client,
    });

    console.log("Quote:", {
      fromAmount: Number(quote.originAmount) / 1e18,
      toAmount: Number(quote.destinationAmount) / 1e18,
      estimatedTime: quote.estimatedExecutionTimeMs / 1000,
    });

    // Execute swap
    const txHashes = await swapManager.executeSwap(quote, userAccount);
    console.log("Swap completed! Transaction hashes:", txHashes);

    return txHashes;
  } catch (error) {
    console.error("Swap failed:", error);
    throw error;
  }
}
```

### Advanced Price Comparison

Compare prices across multiple routes to find the best deal:

```typescript
interface RouteComparison {
  route: any;
  quote: SwapQuote;
  priceImpact: number;
  gasEstimate: bigint;
}

export class PriceComparator {
  private swapManager: SwapManager;

  constructor(swapManager: SwapManager) {
    this.swapManager = swapManager;
  }

  async compareRoutes(
    fromToken: { chainId: number; address: string },
    amount: bigint,
    userAddress: string
  ): Promise<RouteComparison[]> {
    // Get available routes
    const routes = await this.swapManager.getAvailableRoutes({
      originChainId: fromToken.chainId,
      originTokenAddress: fromToken.address,
      limit: 10,
    });

    // Get quotes for each route
    const comparisons: RouteComparison[] = [];

    for (const route of routes) {
      try {
        const quote = await this.swapManager.getQuote({
          fromChainId: route.originToken.chainId,
          fromTokenAddress: route.originToken.address,
          toChainId: route.destinationToken.chainId,
          toTokenAddress: route.destinationToken.address,
          amount,
          userAddress,
          client: this.swapManager.client,
        });

        const priceImpact = this.calculatePriceImpact(quote, amount);
        const gasEstimate = this.estimateGasCosts(quote);

        comparisons.push({
          route,
          quote,
          priceImpact,
          gasEstimate,
        });
      } catch (error) {
        console.warn(`Failed to get quote for route ${route.originToken.symbol} -> ${route.destinationToken.symbol}:`, error);
      }
    }

    // Sort by best output amount
    return comparisons.sort((a, b) =>
      Number(b.quote.destinationAmount) - Number(a.quote.destinationAmount)
    );
  }

  private calculatePriceImpact(quote: SwapQuote, inputAmount: bigint): number {
    // Simplified price impact calculation
    const ratio = Number(quote.destinationAmount) / Number(quote.originAmount);
    return Math.abs(1 - ratio) * 100; // Percentage
  }

  private estimateGasCosts(quote: SwapQuote): bigint {
    // Sum up gas estimates from all transactions
    return quote.steps.reduce((total, step) => {
      return total + step.transactions.reduce((stepTotal: bigint, tx: any) => {
        return stepTotal + (tx.gasLimit || 200000n); // Default estimate
      }, 0n);
    }, 0n);
  }
}
```

<Callout variant="info">
**Gas Optimization Tip:** For frequently traded pairs, consider caching route data to reduce API calls and improve UI responsiveness.
</Callout>

</TabsContent>
</Tabs>


## Key Features

- **Cross-chain swaps** - Exchange tokens across 50+ supported chains
- **Real-time quotes** - Get up-to-date pricing and execution estimates
- **Route optimization** - Find the best path for any token pair
- **Price comparison** - Compare multiple routes to maximize output
- **Status tracking** - Monitor cross-chain transaction progress



## Going Further

- [Send a Payment](/payments/send) - Learn about peer-to-peer transfers
- [Get Routes](/payments/routes) - Explore route discovery APIs
- [Token Prices](/payments/tokens) - Access real-time token pricing
- [Webhooks](/payments/webhooks) - Get notified when swaps complete

## API Reference

- [Bridge.Buy.prepare](/references/typescript/v5/buy/prepare)
- [Bridge.routes](/references/typescript/v5/routes)
- [Bridge.status](/references/typescript/v5/status)